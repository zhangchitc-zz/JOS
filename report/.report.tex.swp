\documentclass{article}

\usepackage{csquotes}
% 使用中文CJK包
\usepackage{CJK}
% 图像插入宏包
\usepackage{graphicx}
% 自定义颜色支持
\usepackage[usenames,dvipsnames]{color}
% 长表格跨页支持
\usepackage{longtable}
% 代码高亮支持
\usepackage{listings}
% 算法伪代码包
\usepackage[ruled,vlined]{algorithm2e}
% 自定义标题格式
\usepackage{titlesec}
% 扩展tabular样式
\usepackage{array}
% 添加页眉页脚
\usepackage{fancyhdr}
% 虚拟正文测试
\usepackage{lipsum}
% 数学环境包
\usepackage{amsmath}
% 首行缩进
\usepackage{indentfirst}
% 树状结构图
\usepackage{tree-dvips}
% 脚注环境
\usepackage{footnote}
% 定制表格线
\usepackage{makecell}
% tikz绘图包
\usepackage{tikz}
% URL超链接
\usepackage[dvips, colorlinks, linkcolor=black]{hyperref}
% 断行URL超链接
\usepackage{breakurl}


% hyperref中文兼容
\pdfstringdefDisableCommands{
\let\CJK@XX\relax
\let\CJK@XXX\relax
\let\CJK@XXXp\relax
\let\CJK@XXXX\relax
\let\CJK@XXXXp\relax
}

\usetikzlibrary{positioning,shapes,shadows,arrows}


% 设置脚注在table中可用
\makesavenoteenv{table}

% 设置标题格式
%\titleformat{\chapter}{\raggedright\Huge\bfseries}{Chapter \thechapter}{1em}{}

% 设置默认字体族, 具体字体请查看texdoc psnfss2e

% 设置Roman字体为Palatino
\renewcommand{\rmdefault}{ppl} 
% 设置TypeWriter字体为Courier
\renewcommand{\ttdefault}{pcr} 

% 设置行距
\setlength{\parskip}{1ex}

% 定义需要的颜色

\definecolor{lightgray}{RGB}{230,230,230}
\definecolor{lightblue}{RGB}{224, 224, 255}
\definecolor{darkblue}{RGB}{192, 192, 255}
\definecolor{lightpink}{RGB}{255, 224, 224}
\definecolor{darkpink}{RGB}{255, 192, 192}
\definecolor{keywordyellow}{RGB}{255, 204, 0}
\definecolor{keywordred}{RGB}{194, 58, 0}
\definecolor{numbercolor}{RGB}{102, 51, 0}

% 设置代码风格

% 定义C语言代码风格
\lstdefinestyle{ccode}
{ 
    language=C, 
    numbers=left, 
    numberstyle=\color{numbercolor},
    basicstyle=\scriptsize\ttfamily\bfseries,
    keywordstyle=\color{blue}, 
    commentstyle=\color{PineGreen},
    stringstyle=\color{red}, 
    frame=shadowbox, 
    frameround=tttt,
    breaklines=true,
    backgroundcolor=\color{lightgray} }

% 定义汇编语言代码风格
\lstdefinestyle{acode}
{ 
    language=,
    morekeywords=[1]{mov, movl, movb, movw, orl, xorw, cli, cld, inb, testb, test, jnz, push, pop, jmp, call, lea, add, sub, ret, jle, outb, ljmp, lgdt, cmp, jne, popal, int, jns},
    morekeywords=[2]{ax, bx, cx, dx, eax, ebx, ecx, edx, cr0, cr1, cr2, cr3, al, ds, es, ss, esp, ebp, esi, edi}, 
    morekeywords=[3]{data, text, bss},
    morekeywords=[4]{long, align, p2align, ascii, fill, globl, space, set, rept, byte, word},
    morecomment=[l]\#,
    numbers=left, 
    numberstyle=\color{numbercolor},
    basicstyle=\scriptsize\ttfamily\bfseries,
    keywordstyle=[1]\color{blue}, 
    keywordstyle=[2]\color{keywordyellow},
    keywordstyle=[3]\color{orange},
    keywordstyle=[4]\color{keywordred},
    commentstyle=\color{PineGreen},
    stringstyle=\color{red}, 
    frame=shadowbox, 
    frameround=tttt,
    breaklines=true,
    backgroundcolor=\color{lightgray} }

    
% 定义命令行输出风格
\lstdefinestyle{console}
{
    language=bash, 
    numbers=none, 
    frame=tRBl,
    basicstyle=\scriptsize\color{green}\ttfamily\bfseries,     
    backgroundcolor=\color{black}}


% 定义exercise输出风格
\lstdefinestyle{exercise}
{
    numbers=none, 
    frame=tRBl,
    breaklines=true,
    breakindent=0pt,
    framexleftmargin=1em,
    framexrightmargin=1em,
    framextopmargin=2ex,
    framexbottommargin=2ex,
    xleftmargin=0.05\linewidth,
    xrightmargin=0.05\linewidth,
    basicstyle=\scriptsize\ttfamily\mdseries,   
    moredelim=[is][\ttfamily\bfseries]{|}{|},
    framerule=0.8pt,
    rulecolor=\color{darkblue}, 
    backgroundcolor=\color{lightblue}}
    

% 定义challenge输出风格
\lstdefinestyle{challenge}
{
    numbers=none, 
    frame=tRBl,
    breaklines=true,
    breakindent=0pt,
    framexleftmargin=1em,
    framexrightmargin=1em,
    framextopmargin=2ex,
    framexbottommargin=2ex,
    xleftmargin=0.05\linewidth,
    xrightmargin=0.05\linewidth,
    basicstyle=\scriptsize\ttfamily\mdseries,   
    moredelim=[is][\ttfamily\bfseries]{|}{|},
    framerule=0.8pt,
    rulecolor=\color{darkpink}, 
    backgroundcolor=\color{lightpink}}
    


% 非常重要, listings关闭非ASCII字符兼容
\lstset{extendedchars=false}


% 定义问题的答案格式
\newcommand{\highlight}[1]{{\bfseries \color{red}  #1}}
% 定义函数名格式
\newcommand{\funcname}[1]{{\ttfamily \small #1}}




\pagestyle{fancy}
\begin{document}
\begin{CJK*}{UTF8}{gkai}

\lhead{操作系统实习报告}
\rhead{张弛, 00848231}
\title{操作系统JOS实习第三次报告}
\author{张弛 \hspace{1ex} 00848231, \\
        zhangchitc@gmail.com}

\maketitle
% 记得在文档末尾插入\clearpage
\tableofcontents
\newpage

\section{Introduction}

我在实验中主要参考了华中科技大学邵志远老师写的JOS实习指导，在邵老师的主页上\burl{http://grid.hust.edu.cn/zyshao/OSEngineering.htm} 可以找到。但是这次实验的指导远远不如lab1的指导详尽，所以我这里需要补充的内容会很多。

内联汇编请参考邵老师的第二章讲义，对于语法讲解的很详细。


\section{User-level Environment Creation and Cooperative Multitasking}

这个部分的MIT文档讲解的比较详细，细节的串接都比较清楚。结合代码的注释写起来不是很困难。

\subsection{Round-Robin Scheduling}

\begin{lstlisting}[style=exercise]
|Exercise 1.| Implement round-robin scheduling in sched_yield() as described above. Don't forget to modify syscall() to dispatch sys_yield().

Modify kern/init.c to create three (or more!) environments that all run the program user/yield.c. You should see the environments switch back and forth between each other five times before terminating, like this:

...
Hello, I am environment 00001001.
Hello, I am environment 00001002.
Hello, I am environment 00001003.
Back in environment 00001001, iteration 0.
Back in environment 00001002, iteration 0.
Back in environment 00001003, iteration 0.
Back in environment 00001001, iteration 1.
Back in environment 00001002, iteration 1.
Back in environment 00001003, iteration 1.
...
After the yield programs exit, the idle environment should run and invoke the JOS kernel debugger. If any of this does not happen, then fix your code before proceeding.
\end{lstlisting}

\funcname{sched\_yield()} 函数比较简单，直接贴代码了：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/sched.c: sched\_yield()}]
void
sched_yield(void)
{
    struct Env *curenvptr = curenv;

    if (curenv == NULL)
        curenvptr = envs;

    int round = 0;
    for (curenvptr ++; round < NENV; round ++, curenvptr ++) {

        if (curenvptr >= envs + NENV) {
            curenvptr = envs + 1;
        }

        if (curenvptr->env_status == ENV_RUNNABLE)
            env_run (curenvptr);
    }

    // Run the special idle environment when nothing else is runnable.
    if (envs[0].env_status == ENV_RUNNABLE)
        env_run(&envs[0]);
    else {
        cprintf("Destroyed all environments - nothing more to do!\n");
        while (1)
            monitor(NULL);
	}
}
\end{lstlisting}

然后修改kern/syscall.c添加相关的分发机制，然后在kern/init.c中系统启动之初创建user\_idle以后再创建user\_yield，这个用户程序的功能就是作五次\funcname{sys\_yield()}的系统调用，并且切换时打印相关的消息:

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/init.c: i386\_init()}]
	// Should always have an idle process as first one.
	ENV_CREATE(user_idle);
        ENV_CREATE(user_yield);
        ENV_CREATE(user_yield);
        ENV_CREATE(user_yield);
\end{lstlisting}

那么启动JOS后应该打印出下列消息：（注意，因为是使用Round Robin策略切换，所以顺序应该是确定的）


\begin{lstlisting}[style=console]
qemu -hda obj/kern/kernel.img -serial mon:stdio
6828 decimal is 15254 octal!
Hooray! Passed all test cases for stdlib!!
Physical memory: 66556K available, base = 640K, extended = 65532K
check_page_alloc() succeeded!
page_check() succeeded!
check_boot_pgdir() succeeded!
enabled interrupts: 1 2
	     Setup timer interrupts via 8259A
enabled interrupts: 0 1 2
	     unmasked timer interrupt
[00000000] new env 00001000
[00000000] new env 00001001
[00000000] new env 00001002
[00000000] new env 00001003
Hello, I am environment 00001001.
Hello, I am environment 00001002.
Hello, I am environment 00001003.
Back in environment 00001001, iteration 0.
Back in environment 00001002, iteration 0.
Back in environment 00001003, iteration 0.
Back in environment 00001001, iteration 1.
Back in environment 00001002, iteration 1.
Back in environment 00001003, iteration 1.
Back in environment 00001001, iteration 2.
Back in environment 00001002, iteration 2.
Back in environment 00001003, iteration 2.
Back in environment 00001001, iteration 3.
Back in environment 00001002, iteration 3.
Back in environment 00001003, iteration 3.
Back in environment 00001001, iteration 4.
All done in environment 00001001.
[00001001] exiting gracefully
[00001001] free env 00001001
Back in environment 00001002, iteration 4.
All done in environment 00001002.
[00001002] exiting gracefully
[00001002] free env 00001002
Back in environment 00001003, iteration 4.
All done in environment 00001003.
[00001003] exiting gracefully
[00001003] free env 00001003
Welcome to the JOS kernel monitor!
Type 'help' for a list of commands.
\end{lstlisting}

\vspace{2em}
\hrule
\vspace{2em}


\begin{lstlisting}[style=exercise]
|Question|

In your implementation of env_run() you should have called lcr3(). Before and after the call to lcr3(), your code makes references (at least it should) to the variable e, the argument to env_run. Upon loading the %cr3 register, the addressing context used by the MMU is instantly changed. But a virtual address (namely e) has meaning relative to a given address context--the address context specifies the physical address to which the virtual address maps. Why can the pointer e be dereferenced both before and after the addressing switch?
\end{lstlisting}

我们先来回顾一下\funcname{env\_run()}里的具体代码：


\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: env\_run()}]
void
env_run(struct Env *e)
{
    if (curenv != e) {
        curenv = e;
        curenv->env_runs ++;
        lcr3 (curenv->env_cr3);
    }

    env_pop_tf (&curenv->env_tf);

    panic("env_run not yet implemented");
}
\end{lstlisting}

我们尝试在未切换到用户页地址之前打印出e在系统页表中的地址，看看是个什么样子：

\begin{lstlisting}[style=console]
[00000000] new env 00001000
[00000000] new env 00001001
[00000000] new env 00001002
[00000000] new env 00001003
zhangchi: e ptr = f01f207c, KERNBASE = f0000000
zhangchi: e ptr = f01f207c, KERNBASE = f0000000
Hello, I am environment 00001001.
zhangchi: e ptr = f01f207c, KERNBASE = f0000000
zhangchi: e ptr = f01f20f8, KERNBASE = f0000000
zhangchi: e ptr = f01f20f8, KERNBASE = f0000000
Hello, I am environment 00001002.
\end{lstlisting}

可以看到e的地址是在KERNBASE以上的系统区，而很明显，在所有用户页地址空间里，KERNBASE以上的空间都是和boot\_pgdir是一样的，指向同一片物理内存区域。所以我们在切换页表的前后e是不受影响的。

\subsection{System Calls for Environment Creation}

这个小节里我一开始最迷惑的就是这个\funcname{sys\_exofork()}对于父进程和子进程的返回值的区别。因为操作系统应该是可以递归的让子进程不断创建子进程的，\highlight{那这里子进程调用返回0又是如何解释？如果他调用老是返回0那如何让其递归的创建子进程？}

这里需要重申一下\funcname{fork()}的机制，因为创建出的子进程和父亲是同一进程，即它们在汇编代码级别是一模一样的，父亲创建一个子进程应该是在一个int 30的中断调用里完成的，这个中断去调用相应的系统\funcname{fork()}代码。比如我们可以看看obj/user/dumbfork.asm看看相关的代码：

\begin{lstlisting}[style=acode, firstnumber=118, title={\scriptsize \ttfamily \bfseries obj/user/dumbfork.asm}]
envid_t
dumbfork(void)
{
  800119:	55                   	push   %ebp
  80011a:	89 e5                	mov    %esp,%ebp
  80011c:	53                   	push   %ebx
  80011d:	83 ec 24             	sub    $0x24,%esp
static __inline envid_t sys_exofork(void) __attribute__((always_inline));
static __inline envid_t
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  800120:	bb 07 00 00 00       	mov    $0x7,%ebx
  800125:	89 d8                	mov    %ebx,%eax
  800127:	cd 30                	int    $0x30
  800129:	89 c3                	mov    %eax,%ebx
	// The kernel will initialize it with a copy of our register state,
	// so that the child will appear to have called sys_exofork() too -
	// except that in the child, this "fake" call to sys_exofork()
	// will return 0 instead of the envid of the child.
	envid = sys_exofork();
	if (envid < 0)
  80012b:	85 c0                	test   %eax,%eax
  80012d:	79 20                	jns    80014f <dumbfork+0x36>
		panic("sys_exofork: %e", envid);
\end{lstlisting}

这个时候，中断调用后创建的子进程和父进程有一样的进程状态，父亲的调用完以后因为这个\funcname{fork()}有一个返回值代表子进程的pid，这个返回值按照lab3的规定应该是在eax里的，所以int 30的下一句汇编代码应该就是把这个eax赋值给相应的变量，如上面代码中800129地址的指令。但是如果切换到子进程继续运行的话，\highlight{不能让它也接受一个和父进程一样的eax（因为这个时候eax不就是它自己的pid么）}，所以为了区分就让它的返回值等于0就好了。即让其eax寄存器设置为0.

其他就没什么太大的疑问了。

\vspace{2em}

\begin{lstlisting}[style=exercise]
|Exercise 2.| Implement the system calls described above in kern/syscall.c. You will need to use various functions in kern/pmap.c and kern/env.c, particularly envid2env(). For now, whenever you call envid2env(), pass 1 in the checkperm parameter. Be sure you check for any invalid system call arguments, returning -E_INVAL in that case. Test your JOS kernel with user/dumbfork and make sure it works before proceeding.
\end{lstlisting}

我们一个函数一个函数的看，首先是刚才提到的\funcname{sys\_exofork()}

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/syscall.c: sys\_exofork()}]
static envid_t
sys_exofork(void)
{
    struct Env *newenv;
    int r = env_alloc (&newenv, sys_getenvid());

    if (r < 0) 
        return r;

    // set not runnnable
    newenv->env_status = ENV_NOT_RUNNABLE;

    // copy trapframe 
    newenv->env_tf = curenv->env_tf;

    // make the child env's return value zero
    newenv->env_tf.tf_regs.reg_eax = 0;

    return newenv->env_id;
}
\end{lstlisting}

这里最重要的就是第17行，让创建好的子进程的eax为0，那么它从系统调用得到的返回值就是0了。

然后是\funcname{env\_set\_status()}，很简单，照着注释写就行

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/syscall.c: env\_set\_status()}]
static int
sys_env_set_status(envid_t envid, int status)
{
    if (status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE)
        return -E_INVAL;

    struct Env *envptr;
    int r = envid2env (envid, &envptr, 1);

    if (r < 0)
        return r;

    envptr->env_status = status;

    return 0;
}
\end{lstlisting}

接下来是\funcname{env\_page\_alloc()}

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/syscall.c: sys\_page\_alloc()}]
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
    if (va >= (void *)UTOP)
        return -E_INVAL;

    if ((perm & PTE_U) == 0 || (perm & PTE_P) == 0)
        return -E_INVAL;
    // PTE_USER = PTE_U | PTE_P | PTE_W | PTE_AVAIL
    if ((perm & ~PTE_USER) > 0)
        return -E_INVAL;

    struct Env *e;
    if (envid2env (envid, &e, 1) < 0)
        return -E_BAD_ENV;

    struct Page *p;
    if (page_alloc (&p) < 0)
        return -E_NO_MEM;

    if (page_insert (e->env_pgdir, p, va, perm) < 0) {
        page_free (p);
        return -E_NO_MEM;
    }

    memset (page2kva (p), 0, PGSIZE);

    return 0;
}
\end{lstlisting}

注意，这里最重要的是最后一句memset，这个在注释中没有提及，但是在邵老师的讲义里面提到了，\highlight{申请了新页面以后注意要给用户进程清空以防止脏数据的情况}。请认真阅读绍老师的讲义。

然后来看\funcname{sys\_page\_map()}

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/syscall.c: sys\_page\_map()}]
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
    if (srcva >= (void *)UTOP || ROUNDUP (srcva, PGSIZE) != srcva
    ||  dstva >= (void *)UTOP || ROUNDUP (dstva, PGSIZE) != dstva)
        return -E_INVAL;

    if ((perm & PTE_U) == 0 || (perm & PTE_P) == 0)
        return -E_INVAL;
    // PTE_USER = PTE_U | PTE_P | PTE_W | PTE_AVAIL
    if ((perm & ~PTE_USER) > 0)
        return -E_INVAL;

    struct Env *srcenv;
    if (envid2env (srcenvid, &srcenv, 1) < 0)
        return -E_BAD_ENV;

    struct Env *dstenv;
    if (envid2env (dstenvid, &dstenv, 1) < 0)
        return -E_BAD_ENV;

    pte_t *pte;
    struct Page *p = page_lookup (srcenv->env_pgdir, srcva, &pte);
    if (p == NULL || ((perm & PTE_W) > 0 && (*pte & PTE_W) == 0))
        return -E_INVAL;

    if (page_insert (dstenv->env_pgdir, p, dstva, perm) < 0)
        return -E_NO_MEM;

    return 0;
}
\end{lstlisting}

没什么需要注意的地方，继续看\funcname{sys\_page\_unmap()}


\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/syscall.c: sys\_page\_unmap()}]
static int
sys_page_unmap(envid_t envid, void *va)
{
    if (va >= (void *)UTOP || ROUNDUP (va, PGSIZE) != va)
        return -E_INVAL;

    struct Env *env;
    if (envid2env (envid, &env, 1) < 0)
        return -E_BAD_ENV;

    page_remove (env->env_pgdir, va);

    return 0;
}
\end{lstlisting}

到此为止这个Exercise涉及的全部代码就已经完成了，当然还有我们要对相应的系统调用号添加分发逻辑。然后我们来考虑运行一下user/dumbfork，首先来看看它的代码，这里节选它的主函数段：


\begin{lstlisting}[style=ccode, firstnumber=9, title={\scriptsize \ttfamily \bfseries user/dumbfork.c: umain()}]
void
umain(void)
{
	envid_t who;
	int i;

	// fork a child process
	who = dumbfork();

	// print a message and yield to the other a few times
	for (i = 0; i < (who ? 10 : 20); i++) {
		cprintf("%d: I am the %s!\n", i, who ? "parent" : "child");
		sys_yield();
	}
}
\end{lstlisting}

这个代码的逻辑就是：父进程创建一个子进程，然后每次打印一条信息以后交出控制权，并且让父进程重复10次而子进程重复20次。

这个逻辑已经很明显了，我们尝试这运行一下，输入make run-dumbfork:


\begin{lstlisting}[style=console]
qemu -hda obj/kern/kernel.img -serial mon:stdio
6828 decimal is 15254 octal!
Hooray! Passed all test cases for stdlib!!
Physical memory: 66556K available, base = 640K, extended = 65532K
check_page_alloc() succeeded!
page_check() succeeded!
check_boot_pgdir() succeeded!
enabled interrupts: 1 2
	     Setup timer interrupts via 8259A
enabled interrupts: 0 1 2
	     unmasked timer interrupt
[00000000] new env 00001000
[00000000] new env 00001001
[00001001] new env 00001002
0: I am the parent!
0: I am the child!
1: I am the parent!
1: I am the child!
2: I am the parent!
2: I am the child!
3: I am the parent!
3: I am the child!
4: I am the parent!
4: I am the child!
5: I am the parent!
5: I am the child!
6: I am the parent!
6: I am the child!
7: I am the parent!
7: I am the child!
8: I am the parent!
8: I am the child!
9: I am the parent!
9: I am the child!
[00001001] exiting gracefully
[00001001] free env 00001001
10: I am the child!
11: I am the child!
12: I am the child!
13: I am the child!
14: I am the child!
15: I am the child!
16: I am the child!
17: I am the child!
18: I am the child!
19: I am the child!
[00001002] exiting gracefully
[00001002] free env 00001002
Welcome to the JOS kernel monitor!
Type 'help' for a list of commands.
\end{lstlisting}

和程序的预期逻辑是一致的。


\begin{lstlisting}[style=console]
\end{lstlisting}

\begin{lstlisting}[style=console]
\end{lstlisting}





\begin{lstlisting}[style=exercise]
\end{lstlisting}

\begin{lstlisting}[style=exercise]
\end{lstlisting}

\begin{lstlisting}[style=exercise]
\end{lstlisting}


\begin{lstlisting}[style=exercise]
\end{lstlisting}



\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/}]
\end{lstlisting}


\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/}]
\end{lstlisting}


\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/}]
\end{lstlisting}



\section{Copy-on-Write Fork}

\section{Preemptive Multitasking and Inter-Process communication (IPC)}




\begin{lstlisting}[style=console]
\end{lstlisting}

\begin{lstlisting}[style=exercise]
\end{lstlisting}

\begin{lstlisting}[style=ccode, firstnumber=257, title={\scriptsize \ttfamily \bfseries inc/mmu.h}]
\end{lstlisting}


\begin{lstlisting}[style=acode, title={\scriptsize \ttfamily \bfseries kern/trapentry.S}]
\end{lstlisting}


\clearpage

\end{CJK*}
\end{document}
	

e