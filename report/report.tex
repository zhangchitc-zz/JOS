\documentclass{article}

\usepackage{csquotes}
% 使用中文CJK包
\usepackage{CJK}
% 图像插入宏包
\usepackage{graphicx}
% 自定义颜色支持
\usepackage[usenames,dvipsnames]{color}
% 长表格跨页支持
\usepackage{longtable}
% 代码高亮支持
\usepackage{listings}
% 算法伪代码包
\usepackage[ruled,vlined]{algorithm2e}
% 自定义标题格式
\usepackage{titlesec}
% 扩展tabular样式
\usepackage{array}
% 添加页眉页脚
\usepackage{fancyhdr}
% 虚拟正文测试
\usepackage{lipsum}
% 数学环境包
\usepackage{amsmath}
% 首行缩进
\usepackage{indentfirst}
% 树状结构图
\usepackage{tree-dvips}
% 脚注环境
\usepackage{footnote}
% 定制表格线
\usepackage{makecell}
% tikz绘图包
\usepackage{tikz}
% URL超链接
\usepackage[dvips, colorlinks, linkcolor=black]{hyperref}
% 断行URL超链接
\usepackage{breakurl}


% hyperref中文兼容
\pdfstringdefDisableCommands{
\let\CJK@XX\relax
\let\CJK@XXX\relax
\let\CJK@XXXp\relax
\let\CJK@XXXX\relax
\let\CJK@XXXXp\relax
}

\usetikzlibrary{positioning,shapes,shadows,arrows}


% 设置脚注在table中可用
\makesavenoteenv{table}

% 设置标题格式
%\titleformat{\chapter}{\raggedright\Huge\bfseries}{Chapter \thechapter}{1em}{}

% 设置默认字体族, 具体字体请查看texdoc psnfss2e

% 设置Roman字体为Palatino
\renewcommand{\rmdefault}{ppl} 
% 设置TypeWriter字体为Courier
\renewcommand{\ttdefault}{pcr} 

% 设置行距
\setlength{\parskip}{1ex}

% 定义需要的颜色

\definecolor{lightgray}{RGB}{230,230,230}
\definecolor{lightblue}{RGB}{224, 224, 255}
\definecolor{darkblue}{RGB}{192, 192, 255}
\definecolor{lightpink}{RGB}{255, 224, 224}
\definecolor{darkpink}{RGB}{255, 192, 192}
\definecolor{keywordyellow}{RGB}{255, 204, 0}
\definecolor{keywordred}{RGB}{194, 58, 0}
\definecolor{numbercolor}{RGB}{102, 51, 0}

% 设置代码风格

% 定义C语言代码风格
\lstdefinestyle{ccode}
{ 
    language=C, 
    numbers=left, 
    numberstyle=\color{numbercolor},
    basicstyle=\scriptsize\ttfamily\bfseries,
    keywordstyle=\color{blue}, 
    commentstyle=\color{PineGreen},
    stringstyle=\color{red}, 
    frame=shadowbox, 
    frameround=tttt,
    breaklines=true,
    backgroundcolor=\color{lightgray} }

% 定义汇编语言代码风格
\lstdefinestyle{acode}
{ 
    language=,
    morekeywords=[1]{mov, movl, movb, movw, orl, xorw, cli, cld, inb, testb, test, jnz, push, pop, jmp, call, lea, add, sub, ret, jle, outb, ljmp, lgdt, cmp, jne, popal, int},
    morekeywords=[2]{ax, bx, cx, dx, eax, ebx, ecx, edx, cr0, cr1, cr2, cr3, al, ds, es, ss, esp, ebp, esi, edi}, 
    morekeywords=[3]{data, text, bss},
    morekeywords=[4]{long, align, p2align, ascii, fill, globl, space, set, rept, byte, word},
    morecomment=[l]\#,
    numbers=left, 
    numberstyle=\color{numbercolor},
    basicstyle=\scriptsize\ttfamily\bfseries,
    keywordstyle=[1]\color{blue}, 
    keywordstyle=[2]\color{keywordyellow},
    keywordstyle=[3]\color{orange},
    keywordstyle=[4]\color{keywordred},
    commentstyle=\color{PineGreen},
    stringstyle=\color{red}, 
    frame=shadowbox, 
    frameround=tttt,
    breaklines=true,
    backgroundcolor=\color{lightgray} }

    
% 定义命令行输出风格
\lstdefinestyle{console}
{
    language=bash, 
    numbers=none, 
    frame=tRBl,
    basicstyle=\scriptsize\color{green}\ttfamily\bfseries,     
    backgroundcolor=\color{black}}


% 定义exercise输出风格
\lstdefinestyle{exercise}
{
    numbers=none, 
    frame=tRBl,
    breaklines=true,
    breakindent=0pt,
    framexleftmargin=1em,
    framexrightmargin=1em,
    framextopmargin=2ex,
    framexbottommargin=2ex,
    xleftmargin=0.05\linewidth,
    xrightmargin=0.05\linewidth,
    basicstyle=\scriptsize\ttfamily\mdseries,   
    moredelim=[is][\ttfamily\bfseries]{|}{|},
    framerule=0.8pt,
    rulecolor=\color{darkblue}, 
    backgroundcolor=\color{lightblue}}
    

% 定义challenge输出风格
\lstdefinestyle{challenge}
{
    numbers=none, 
    frame=tRBl,
    breaklines=true,
    breakindent=0pt,
    framexleftmargin=1em,
    framexrightmargin=1em,
    framextopmargin=2ex,
    framexbottommargin=2ex,
    xleftmargin=0.05\linewidth,
    xrightmargin=0.05\linewidth,
    basicstyle=\scriptsize\ttfamily\mdseries,   
    moredelim=[is][\ttfamily\bfseries]{|}{|},
    framerule=0.8pt,
    rulecolor=\color{darkpink}, 
    backgroundcolor=\color{lightpink}}
    


% 非常重要, listings关闭非ASCII字符兼容
\lstset{extendedchars=false}


% 定义问题的答案格式
\newcommand{\highlight}[1]{{\bfseries \color{red}  #1}}
% 定义函数名格式
\newcommand{\funcname}[1]{{\ttfamily \small #1}}




\pagestyle{fancy}
\begin{document}
\begin{CJK*}{UTF8}{gkai}

\lhead{操作系统实习报告}
\rhead{张弛, 00848231}
\title{操作系统JOS实习第三次报告}
\author{张弛 \hspace{1ex} 00848231, \\
        zhangchitc@gmail.com}

\maketitle
% 记得在文档末尾插入\clearpage
\tableofcontents
\newpage

\section{Introduction}

我在实验中主要参考了华中科技大学邵志远老师写的JOS实习指导，在邵老师的主页上\burl{http://grid.hust.edu.cn/zyshao/OSEngineering.htm} 可以找到。但是这次实验的指导远远不如lab1的指导详尽，所以我这里需要补充的内容会很多。

内联汇编请参考邵老师的第二章讲义，对于语法讲解的很详细。

\section{User Environments and Exception Handling}


\subsection{Environment State}

MIT的材料里对于\funcname{struct Env}的讲解很详细。其中唯一需要注意的就是\funcname{struct Trapframe}的理解，在这里还无法展开叙述。这个我们在后面具体编程的时候会提到。

\subsection{Allocating the Environments Array}


\begin{lstlisting}[style=exercise]
|Exercise 1|. Modify i386_vm_init() in kern/pmap.c to allocate and map the envs array. This array consists of exactly NENV instances of the Env structure allocated much like how you allocated the pages array. Also like the pages array, the memory backing envs should also be mapped user read-only at UENVS (defined in inc/memlayout.h) so user processes can read from this array.

You should run your code and make sure check_boot_pgdir() succeeds.
\end{lstlisting}

这个练习比较简单，有了前面设置pages数组的经验，对于envs的理解就很顺畅了。我们来看看具体的代码：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/pmap.c: i386\_vm\_init ()}]
	pages = boot_alloc (npage * sizeof (struct Page), PGSIZE);

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	
        envs = boot_alloc (NENV * sizeof (struct Env), PGSIZE);
\end{lstlisting}

分配了物理空间以后，再在虚拟地址空间为其创建映射：


\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/pmap.c: i386\_vm\_init ()}]
	//////////////////////////////////////////////////////////////////////
	// Map the 'envs' array read-only by the user at linear address UENVS
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	//
        boot_map_segment (
            pgdir,
            UENVS,
            ROUNDUP (NENV * sizeof (struct Env), PGSIZE),
            PADDR ((uintptr_t) envs),
            PTE_U);
\end{lstlisting}


\subsection{Creating and Running Environments}

\begin{lstlisting}[style=exercise]
|Exercise 2|. In the file env.c, finish coding the following functions:

|env_init():|
        initialize all of the Env structures in the envs array and add them to the env_free_list.
|env_setup_vm():|
        allocate a page directory for a new environment and initialize the kernel portion of the new environment's address space.
|segment_alloc():|
        allocates and maps physical memory for an environment
|load_icode():|
        you will need to parse an ELF binary image, much like the boot loader already does, and load its contents into the user address space of a new environment.
|env_create():|
        allocate an environment with env_alloc and call load_icode load an ELF binary into it.
|env_run():|
        start a given environment running in user mode.

As you write these functions, you might find the new cprintf verb %e useful -- it prints a description corresponding to an error code. For example,

	r = -E_NO_MEM;
	panic("env_alloc: %e", r);
	
will panic with the message "env_alloc: out of memory".
\end{lstlisting}

\vspace{4em}

我们一个一个函数的来看把，首先是\funcname{env\_init()}:

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: env\_init ()}]
void
env_init(void)
{
	int i;

	LIST_INIT(&env_free_list);
	for (i = NENV - 1; i >= 0; i--) {
		envs[i].env_id = 0;
                envs[i].env_status = ENV_FREE; 
		LIST_INSERT_HEAD(&env_free_list, &envs[i], env_link);
	}
}
\end{lstlisting}

没有什么好说的，类比pages对应的\funcname{page\_init()}写就行了。接下来看 \funcname{ env\_setup\_vm() }

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: env\_setup\_vm ()}]
static int
env_setup_vm(struct Env *e)
{
	int i, r;
	struct Page *p = NULL;

	// Allocate a page for the page directory
	if ((r = page_alloc(&p)) < 0)
		return r;
		
        e->env_pgdir = page2kva (p);
        e->env_cr3 = page2pa (p);

        memmove (e->env_pgdir, boot_pgdir, PGSIZE);
        memset (e->env_pgdir, 0, PDX(UTOP) * sizeof (pde_t));
   
        p->pp_ref ++;
    
\end{lstlisting}

这里主要注意的是第14和15行代码。因为在UTOP之上的所有映射对于任何一个地址空间都是一样的（无论是对于内核地址空间还是对于任意一个用户地址空间而言），他们都和在lab2中对于内核地址空间设置的静态映射一样（静态映射就是没有实际分配物理页，即映射是通过\funcname{boot\_map\_segment()}而非\funcname{page\_insert()}），所以这里我们能直接拷贝系统页目录boot\_pgdir中的内容。

接下来看看函数\funcname{segment\_alloc()}

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: segment\_alloc ()}]
static void
segment_alloc(struct Env *e, void *va, size_t len)
{
    va = ROUNDDOWN (va, PGSIZE);
    len = ROUNDUP (len, PGSIZE);

    struct Page *pp;
    int r;

    for (; len > 0; len -= PGSIZE, va += PGSIZE) {
        r = page_alloc (&pp);

        if (r != 0)
            panic ("segment_alloc: physical page allocation failed  %e", r);

        r = page_insert (e->env_pgdir, pp, va, PTE_U|PTE_W);

        if (r != 0)
            panic ("segment_alloc: page mapping failed  %e", r);
    } 
}
\end{lstlisting}

这个函数的作用是在e代表的用户虚拟地址空间中从va开始的地址分配出len长度的区域，准备写入数据。

有点类似lab2中的 \funcname{boot\_map\_segment()} ，但是他们是不一样的。 \funcname{boot\_map\_segment()} 的操作空间是内核虚拟地址空间boot\_pgdir。它提供的映射是静态映射，不涉及物理页的分配。而\funcname{segment\_alloc()} 则是要对实际的物理页面分配映射到当前用户的虚拟地址空间中。

弄清楚这两种映射机制的区别，上面的代码就很好理解了，看下一个函数\funcname{load\_icode()}


\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: load\_icode ()}]
static void
load_icode(struct Env *e, uint8_t *binary, size_t size)
{
    struct Elf *ELFHDR = (struct Elf*) binary;
    struct Proghdr *ph, *eph;

    // is this a valid ELF?
    if (ELFHDR->e_magic != ELF_MAGIC)
        panic ("load_icode: Not a valid ELF");

    ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
    eph = ph + ELFHDR->e_phnum;

    lcr3 (e->env_cr3);
    for (; ph < eph; ph++) {
        if (ph->p_type == ELF_PROG_LOAD) {
            segment_alloc (e, (void*) ph->p_va, ph->p_memsz);
            memset ((void *)ph->p_va, 0, ph->p_memsz);
            memmove ((void *)ph->p_va, binary + ph->p_offset, ph->p_filesz);
       }
    }
    lcr3 (boot_cr3);
    
    e->env_tf.tf_eip = ELFHDR->e_entry;

    segment_alloc (e, (void*) (USTACKTOP - PGSIZE), PGSIZE);
}
\end{lstlisting}

因为MIT的说明里提到过，因为JOS到现在为止还没有文件系统，所以为了测试我们能运行用户程序，现在的做法是将用户程序编译以后\highlight{和内核链接到一起}（即用户程序紧接着内核后面放置）。所以这个函数的作用就是将嵌入在内核中的用户程序取出释放到相应链接器指定好的用户虚拟空间里。这里的binary指针，就是用户程序在内核中的开始位置的虚拟地址。

按照注释的提示，我们可以参照boot/main.c来完成相应的载入，但是有几个地方需要注意

\begin{enumerate}
\item{对于用户程序ELF文件的每个程序头ph，ph$\rightarrow$p\_memsz和ph$\rightarrow$p\_filesz是两个概念，前者是该程序头应在\highlight{内存中占用的空间大小}，而后者是实际该程序头\highlight{占用的文件大小}。他们俩的区别就是ELF文件中BSS节中那些没有被初始化的静态变量，这些变量不会被分配文件储存空间，但是在实际载入后，需要在内存中给与相应的空间，并且全部初始化为0。所以具体来讲，就是每个程序段ph，总共占用p\_memsz的内存，前面p\_filesz的空间从binary的对应内存复制过来，后面剩下的空间全部清0}
\item{ph$\rightarrow$p\_va是该程序段应该被放入的虚拟空间地址，但是注意，在这个时候，虚拟地址空间是\highlight{用户环境Env的虚拟地址空间}。可是，在进入 \funcname{load\_icode()} 时，是内核态进入的，所以虚拟地址空间还是内核的空间。我们要如何对用户的虚拟空间进行操作呢？看到第15行:

\begin{lstlisting}[style=ccode, firstnumber=15, title={\scriptsize \ttfamily \bfseries kern/env.c: load\_icode ()}]
    lcr3 (e->env_cr3);
\end{lstlisting}

这个语句在我们进入每个程序头进行具体设置时，将页表切换到用户虚拟地址空间。这样我们就可以方便的在后面使用memset和memmove等函数对一个虚拟地址进行相应的操作了。其中e$\rightarrow$env\_cr3的值是在前面的 \funcname{env\_setup\_vm()} 设置好的。

但是仍要小心的是，对于ELF载入完毕以后，我们就不需要对用户空间进行操作了，所以记得在22行重新切回到内核虚拟地址空间来。}
\item{注释中还提到了要对程序的入口地址作一定的设置，这里对应的操作是
\begin{lstlisting}[style=ccode, firstnumber=24, title={\scriptsize \ttfamily \bfseries kern/env.c: load\_icode ()}]
    e->env_tf.tf_eip = ELFHDR->e_entry;
\end{lstlisting}

这里涉及到对 struct Trapframe 结构的具体介绍，我们留到下一个函数说明 \funcname{env\_create()} 的时候进行详细介绍。
}
\end{enumerate}


\vspace{2em}

继续看下个函数\funcname{env\_create()}

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: env\_create()}]
void
env_create(uint8_t *binary, size_t size)
{
    struct Env *e;
    int r;

    r = env_alloc (&e, 0);

    if (r < 0)
        panic ("env_create: %e", r);

    load_icode (e, binary, size);
}
\end{lstlisting}

到这个函数为止，系统就为一个用户程序的运行做好了一切准备，在这个函数中，接受内核传入的用户程序的所在地址binary（内核地址），然后为其创建用户进程空间，并且将其载入到相应的虚拟地址上。接下来的 \funcname{env\_run()}就可以开始真正的运行一个程序了。

这里调用了过程 \funcname{env\_alloc()} 来为用户进程分配一个struct Env，这个过程是JOS替我们写好的，但是还是有必要好好看看，便于我们对struct Env和struct Trapframe的理解。

MIT的资料中详细介绍了struct Env的结构：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries inc/env.h}]
struct Env {
        struct Trapframe env_tf;        // Saved registers
        LIST_ENTRY(Env) env_link;       // Free list link pointers
        envid_t env_id;                 // Unique environment identifier
        envid_t env_parent_id;          // env_id of this env's parent
        unsigned env_status;            // Status of the environment
        uint32_t env_runs;              // Number of times environment has run

        // Address space
        pde_t *env_pgdir;               // Kernel virtual address of page dir
        physaddr_t env_cr3;             // Physical address of page dir
};
\end{lstlisting}

其中env\_tf的说明是保存了用户进程被切换出来时CPU的状态信息。我们去inc/trap.h中找寻其具体定义：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries inc/trap.h}]
struct PushRegs {
	/* registers as pushed by pusha */
	uint32_t reg_edi;
	uint32_t reg_esi;
	uint32_t reg_ebp;
	uint32_t reg_oesp;		/* Useless */
	uint32_t reg_ebx;
	uint32_t reg_edx;
	uint32_t reg_ecx;
	uint32_t reg_eax;
} __attribute__((packed));

struct Trapframe {
	struct PushRegs tf_regs;
	uint16_t tf_es;
	uint16_t tf_padding1;
	uint16_t tf_ds;
	uint16_t tf_padding2;
	uint32_t tf_trapno;
	/* below here defined by x86 hardware */
	uint32_t tf_err;
	uintptr_t tf_eip;
	uint16_t tf_cs;
	uint16_t tf_padding3;
	uint32_t tf_eflags;
	/* below here only when crossing rings, such as from user to kernel */
	uintptr_t tf_esp;
	uint16_t tf_ss;
	uint16_t tf_padding4;
} __attribute__((packed));
\end{lstlisting}

其他的都很好理解，某些padding开头的变量是为了让数据补齐4Byte。

我们看到，Trapframe保存的都是一些系统关键的寄存器。这里我们只需要特别关注4个寄存器，涉及到程序执行的控制流问题：

\begin{itemize}
\item{EFLAGS： 状态寄存器，这个我们暂时用不到}
\item{EIP：Instruction Pointer，当前执行的汇编指令的地址}
\item{ESP：当前的栈顶地址}
\item{EBP：辅助用，当前过程的帧在栈中的开始地址（高地址）即EBP到EIP中就是此过程的帧}
\end{itemize}

其中EBP由程序自行操作，而其他三者都会被在执行汇编指令时被改变。ESP就不说了，push和pop指令都是以ESP指针为操作目标的。至于EIP，在lab1中的运行栈那一节，我们看到了C程序编译后压栈的具体信息，其中就可以看到EIP。现在我们可以来看看在程序调用call时具体是如何修改EIP的。通过查询{\ttfamily \bfseries IA-32 Intel Architecture Software Developer's Manuals } 中的  {\ttfamily \bfseries Volume 2A: Instruction Set Reference, A-M } 中的CALL指令，我们可以看到其详细的执行流程：


\begin{algorithm}[htp]
\dontprintsemicolon
\Begin{
$tempEIP \longleftarrow EIP + DEST;$\;
Push($EIP$);\;
$EIP \longleftarrow tempEIP;$\;
}
\caption{CALL - Call Procedure}
\end{algorithm}

这个是我个人简化后最关键的部分，实际上指令的流程涉及到32位、64位、访问权限、以及长跳转和短跳转的各种问题，不过那不是我们关心的。我们只需要知道\highlight{它对EIP和ESP作了什么
}就好了。

从上面简单的三条语句我们可以知道，在进入新的过程体之前，老的EIP就被系统压入了堆栈以便后面返回时使用，然后将新的执行地址放入了EIP。CALL执行完以后，ESP和EIP都发生了改变。

同样的有调用就有返回，我们去看看RET指令的详细手册：

\begin{algorithm}[htp]
\dontprintsemicolon
\Begin{
$EIP \longleftarrow$ Pop();\;
}
\caption{RET - Return from Procedure}
\end{algorithm}

看着很简单，如果涉及保护模式和实模式的切换，那么还有相应段寄存器CS的保存切换问题，在IRET中我们就可以看到相应的逻辑，现在我们先可以不管。

\vspace{4em}

好了，看完Trapframe的内部结构和关键寄存器以后，我们回到Trapframe的讨论。既然这里保存了程序执行所需要的状态，那么刚才在 \funcname{load\_icode()} 中是如何设置的呢，在 \funcname {env\_create() }调用\funcname{load\_icode()}之前分配用户环境 \funcname{env\_alloc()} 。我们进这里看看：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: env\_alloc()}]
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = LIST_FIRST(&env_free_list)))
		return -E_NO_FREE_ENV;

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
		return r;

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
	if (generation <= 0)	// Don't create a negative env_id.
		generation = 1 << ENVGENSHIFT;
	e->env_id = generation | (e - envs);
	
	// Set the basic status variables.
	e->env_parent_id = parent_id;
	e->env_status = ENV_RUNNABLE;
	e->env_runs = 0;

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));

	// Set up appropriate initial values for the segment registers.
	// GD_UD is the user data segment selector in the GDT, and 
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.
	e->env_tf.tf_ds = GD_UD | 3;
	e->env_tf.tf_es = GD_UD | 3;
	e->env_tf.tf_ss = GD_UD | 3;
	e->env_tf.tf_esp = USTACKTOP;
	e->env_tf.tf_cs = GD_UT | 3;
	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(e, env_link);
	*newenv_store = e;

	cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
	return 0;
}
\end{lstlisting}

我们只需要关注从26行开始以后的内容，这里开始对e$\rightarrow$env\_tf进行设置。有几个关键点：

\begin{itemize}
\item{tf\_esp：初始化为USTACKTOP，表示当前用户栈为空}
\item{tf\_cs: 初始化为user text segment selector，权限为用户可访问}
\item{tf\_eip: 这里没有设置，但是注释告诉我们了该由我们设置，很显然，这里eip的值就是我们在 \funcname{load\_icode()} 里应该设置的用户程序入口地址}
\end{itemize}

这样梳理一遍以后，我们就可以对 \funcname{load\_icode()} 里那行设置入口地址代码完全理解了。

看到最后一个要完成的过程 \funcname{env\_run()}


\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: env\_run()}]
void
env_run(struct Env *e)
{
    if (curenv != e) {
        curenv = e;
        curenv->env_runs ++;
        lcr3 (curenv->env_cr3);
    }

    env_pop_tf (&curenv->env_tf);

	panic("env_run not yet implemented");
}
\end{lstlisting}

这里的一个问题就是处理重复切换到当前用户环境的判断，只有是切换到一个新的用户环境时，才需要启用新的用户页面。这个过程里最主要的任务是理解 \funcname{env\_pop\_tf()} ，这个过程是真正负责切换到用户程序的过程：


\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: env\_pop\_tf()}]
void
env_pop_tf(struct Trapframe *tf)
{
	__asm __volatile("movl %0,%%esp\n"
		"\tpopal\n"
		"\tpopl %%es\n"
		"\tpopl %%ds\n"
		"\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */
		"\tiret"
		: : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
}
\end{lstlisting}

我们来尝试理解这段内联汇编：

\begin{lstlisting}[style=acode, firstnumber=4]
        movl %0,%%esp
\end{lstlisting}

这里出现了占位符\%0，通过后面的参数可以看到这里的占位符代表的是memory中的变量tf，即Trapframe的指针地址。这里把它传给esp是什么意思？看到后面的各种pop命令，就可以知道，这里的想法是把Trapframe看作一个存储了很多内容的栈，然后利用pop命令一个一个输出到我们想要重置的寄存器里。因为我们知道弹栈的时候栈指针是不断加的过程（栈的生长是栈指针不断减），所以将ESP设置为Trapframe所在内存的首地址，就可以以内存中的排布顺序释放出所有的内容了。非常的巧妙！

\begin{lstlisting}[style=acode, firstnumber=5]
        popal
\end{lstlisting}

通过查询手册，可以得到popal的执行明细：

\begin{algorithm}[htp]
\dontprintsemicolon
\Begin{
$EDI \longleftarrow$ Pop();\;
$ESI \longleftarrow$ Pop();\;
$EBP \longleftarrow$ Pop();\;
$ESP \longleftarrow ESP + 4$ ;(* Skip next 4 bytes of stack *)\;
$EBX \longleftarrow$ Pop();\;
$EDX \longleftarrow$ Pop();\;
$ECX \longleftarrow$ Pop();\;
$EAX \longleftarrow$ Pop();\;
}
\caption{POPA - Pop All General Purpose Registers}
\end{algorithm}

第一句就输出了这么多寄存器，这里每一次Pop ()，就是从ESP指向的Trapframe里拿出4个Byte，我们来看看Trapframe的前8个DWORD是什么：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries inc/trap.h}]
struct PushRegs {
	/* registers as pushed by pusha */
	uint32_t reg_edi;
	uint32_t reg_esi;
	uint32_t reg_ebp;
	uint32_t reg_oesp;		/* Useless */
	uint32_t reg_ebx;
	uint32_t reg_edx;
	uint32_t reg_ecx;
	uint32_t reg_eax;
} __attribute__((packed));

struct Trapframe {
	struct PushRegs tf_regs;
	uint16_t tf_es;
	uint16_t tf_padding1;
	uint16_t tf_ds;
	uint16_t tf_padding2;
	uint32_t tf_trapno;
	/* below here defined by x86 hardware */
	uint32_t tf_err;
	uintptr_t tf_eip;
	uint16_t tf_cs;
	uint16_t tf_padding3;
	uint32_t tf_eflags;
	/* below here only when crossing rings, such as from user to kernel */
	uintptr_t tf_esp;
	uint16_t tf_ss;
	uint16_t tf_padding4;
} __attribute__((packed));
\end{lstlisting}

可以看到前8个DWORD为一个struct PushRegs，\highlight{这里面的定义顺序和popal里设置的顺序是完全对应的！}可见PushRegs的定义也是经过了缜密的思考的，非常的巧妙，利用一句汇编指令就完成了这么多寄存器的设置。

后面几句汇编代码就很好理解了，直到这句：

\begin{lstlisting}[style=acode, firstnumber=5]
        iret
\end{lstlisting}

再次求助INTEL的指令手册，可以看到IRET和RET的不同：

\begin{algorithm}[htp]
\dontprintsemicolon
\Begin{
$EIP \longleftarrow$ Pop();\;
$CS \longleftarrow$ Pop();\;
$FLAGS \longleftarrow$ Pop();\;
}
\caption{IRET - Interrupt Return}
\end{algorithm}

因为IRET涉及到中断返回的各种控制，所以在保护模式以及实模式切换中会涉及段寄存器切换以及访问控制的问题，实际的控制流非常非常非常复杂，有兴趣的同学可以参考手册里的详细说明。

这个时候执行的IRET语句，会把Trapframe里的下面三个成员放入相应的寄存器

\begin{lstlisting}[style=ccode, numbers=none]
	uintptr_t tf_eip;
	uint16_t tf_cs;
	uint16_t tf_padding3;
	uint32_t tf_eflags;
\end{lstlisting}

这些成员我们在\funcname{env\_alloc()} 以及\funcname{load\_icode()}中都设置好了，其中EIP为用户程序入口地址，CS为用户程序代码段段基址。

那么执行完这条语句以后，CPU再往下执行的第一条语句，应该就是用户程序的第一条指令了。

所以说\funcname{env\_run()}和 \funcname{env\_pop\_tf()}都是没有返回的。

\vspace{2em}

\hrule

\vspace{2em}

到这里，我们的Exercise 2就算做完了，但是编译启动JOS发现它给出了Triple fault的错误信息。在MIT的课程材料上解释了这样的原因。是因为我们没有对中断表进行相应的设置，以至于用户程序在调用系统终端输出字符时产生了错误。但是我们需要认为的确认一下是否真的错误是由中断而不是其他设置造成的，所以我们启动GDB调试，选择在\funcname{env\_pop\_tf()}函数停下：

\begin{lstlisting}[style=console]
The target architecture is assumed to be i8086
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b
0x0000fff0 in ?? ()
+ symbol-file obj/kern/kernel
(gdb) b env_pop_tf
Breakpoint 1 at 0xf0103128: file kern/env.c, line 523.
(gdb) c
Continuing.
The target architecture is assumed to be i386
=> 0xf0103128 <env_pop_tf>:	push   %ebp

Breakpoint 1, env_pop_tf (tf=0xf01af000) at kern/env.c:523
523	{
(gdb) 
\end{lstlisting}

从这里开始单步跟踪，在IRET指令之前停下来，我们在这里查看寄存器的信息看是否都被设置好了：

\begin{lstlisting}[style=console]
(gdb) next
=> 0xf010312e <env_pop_tf+6>:	mov    0x8(%ebp),%esp
525		__asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf0103131 <env_pop_tf+9>:	popa   
0xf0103131	525		__asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf0103132 <env_pop_tf+10>:	pop    %es
0xf0103132 in env_pop_tf (tf=???) at kern/env.c:525
525		__asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf0103133 <env_pop_tf+11>:	pop    %ds
0xf0103133	525		__asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf0103134 <env_pop_tf+12>:	add    $0x8,%esp
0xf0103134	525		__asm __volatile("movl %0,%%esp\n"
(gdb) si
=> 0xf0103137 <env_pop_tf+15>:	iret   
0xf0103137	525		__asm __volatile("movl %0,%%esp\n"
(gdb) info registers 
eax            0x0	0
ecx            0x0	0
edx            0x0	0
ebx            0x0	0
esp            0xf01af030	0xf01af030
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0xf0103137	0xf0103137 <env_pop_tf+15>
eflags         0x96	[ PF AF SF ]
cs             0x8	8
ss             0x10	16
ds             0x23	35
es             0x23	35
fs             0x23	35
gs             0x23	35
(gdb) 
\end{lstlisting}

从EAX、ECX等寄存器中看到都被清0了，这个和我们在\funcname{env\_alloc()}中看到的设置是一致的，但是在IRET执行之前CS和EIP两个寄存器都还看不到，不过没有关系，我们知道栈顶的接下来三个DWORD分别为EIP、CS和EFLAGS，我们查看一下栈顶的这三个DWORD：

\begin{lstlisting}[style=console]
(gdb) x/3x 0xf01af030
0xf01af030:	0x00800020	0x0000001b	0x00000000
(gdb) 
\end{lstlisting}

可以看到EIP的值为0x00800020即用户程序的入口地址，我们可以打开user/user.ld文件查看一下：

\begin{lstlisting}[style=ccode, language=make, firstnumber=4, title={\scriptsize \ttfamily \bfseries user/user.ld}]
OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(_start)

SECTIONS
{
	/* Load programs at this address: "." means the current address */
	. = 0x800020;

	.text : {
		*(.text .stub .text.* .gnu.linkonce.t.*)
	}
\end{lstlisting}

可以看到第11行链接器对于程序入口地址的设置，和我们看到的调试结果是符合的。这就说明我们正确的将入口地址加载进来了，接下来我们看看是否正确载入了用户程序的ELF文件：


\begin{lstlisting}[style=console]
(gdb) si
=> 0x800020:	cmp    $0xeebfe000,%esp
0x00800020 in ?? ()
(gdb) x/6i 0x800020
=> 0x800020:	cmp    $0xeebfe000,%esp
   0x800026:	jne    0x80002c
   0x800028:	push   $0x0
   0x80002a:	push   $0x0
   0x80002c:	call   0x800060
   0x800031:	jmp    0x800031
(gdb) 
\end{lstlisting}

实际的用户程序hello的汇编代码可以在obj/user/hello.asm中找到：

\begin{lstlisting}[style=acode, firstnumber=5, title={\scriptsize \ttfamily \bfseries obj/user/hello.asm}]
Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 2f 00 00 00       	call   800060 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
	...
\end{lstlisting}

可以看到和输出是一致的，从这里可以知道我们的\funcname{load\_icode()} 的载入是正常工作的。

我们找到MIT教材中提到的\funcname{sys\_cputs()}函数中的中断指令在用户程序中的位置：

\begin{lstlisting}[style=acode, firstnumber=2074, title={\scriptsize \ttfamily \bfseries obj/user/hello.asm}]
void
sys_cputs(const char *s, size_t len)
{
  800d3c:	55                   	push   %ebp
  800d3d:	89 e5                	mov    %esp,%ebp
  800d3f:	83 ec 0c             	sub    $0xc,%esp
  800d42:	89 1c 24             	mov    %ebx,(%esp)
  800d45:	89 74 24 04          	mov    %esi,0x4(%esp)
  800d49:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  800d4d:	b8 00 00 00 00       	mov    $0x0,%eax
  800d52:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  800d55:	8b 55 08             	mov    0x8(%ebp),%edx
  800d58:	89 c3                	mov    %eax,%ebx
  800d5a:	89 c7                	mov    %eax,%edi
  800d5c:	89 c6                	mov    %eax,%esi
  800d5e:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  800d60:	8b 1c 24             	mov    (%esp),%ebx
  800d63:	8b 74 24 04          	mov    0x4(%esp),%esi
  800d67:	8b 7c 24 08          	mov    0x8(%esp),%edi
  800d6b:	89 ec                	mov    %ebp,%esp
  800d6d:	5d                   	pop    %ebp
  800d6e:	c3                   	ret    
\end{lstlisting}

可以看到中断调用的地址为0x800d5e，我们尝试着在这里设下断点，看JOS能否运行到这里：

\begin{lstlisting}[style=console]
(gdb) b *0x800d5e
Breakpoint 2 at 0x800d5e
(gdb) c
Continuing.
=> 0x800d5e:	int    $0x30

Breakpoint 2, 0x00800d5e in ?? ()
(gdb) si
=> 0x800d5e:	int    $0x30

Breakpoint 2, 0x00800d5e in ?? ()
(gdb) 
\end{lstlisting}

可以看到JOS成功运行到了该断点，再执行一条指令，EIP没有发生变化，这个时候看QEMU的输出信息，发现已经产生Triple fault：


\begin{lstlisting}[style=console]
zhangchi@zhangchi-vostro1400:~/lab$ make qemu-gdb
sed "s/localhost:1234/localhost:26000/" < .gdbinit.tmpl > .gdbinit
***
*** Now run 'gdb'.
***
qemu -hda obj/kern/kernel.img -serial mon:stdio -S -gdb tcp::26000
6828 decimal is 15254 octal!
Hooray! Passed all test cases for stdlib!!
Physical memory: 66556K available, base = 640K, extended = 65532K
check_page_alloc() succeeded!
page_check() succeeded!
check_boot_pgdir() succeeded!
[00000000] new env 00001000
EAX=00000000 EBX=00000000 ECX=0000000d EDX=eebfde88
ESI=00000000 EDI=00000000 EBP=eebfde60 ESP=eebfde54
EIP=00800d5e EFL=00000092 [--S-A--] CPL=3 II=0 A20=1 SMM=0 HLT=0
ES =0023 00000000 ffffffff 00cff300 DPL=3 DS   [-WA]
CS =001b 00000000 ffffffff 00cffa00 DPL=3 CS32 [-R-]
SS =0023 00000000 ffffffff 00cff300 DPL=3 DS   [-WA]
DS =0023 00000000 ffffffff 00cff300 DPL=3 DS   [-WA]
FS =0023 00000000 ffffffff 00cff300 DPL=3 DS   [-WA]
GS =0023 00000000 ffffffff 00cff300 DPL=3 DS   [-WA]
LDT=0000 00000000 00000000 00008200 DPL=0 LDT
TR =0028 f017c8e0 00000068 f0408917 DPL=0 TSS32-avl
GDT=     f011a320 0000002f
IDT=     f017c0e0 000007ff
CR0=80050033 CR2=00000000 CR3=0005c000 CR4=00000000
DR0=00000000 DR1=00000000 DR2=00000000 DR3=00000000 
DR6=ffff0ff0 DR7=00000400
Triple fault.  Halting for inspection via QEMU monitor.

\end{lstlisting}

所以到目前为止，我们写出的JOS的运行一切正常。


\subsection{Handling Interrupts and Exceptions}


\subsection{Basics of Protected Control Transfer}

\subsection{Types of Exceptions and Interrupts}

\subsection{An Example}

\subsection{Nested Exceptions and Interrupts}

\subsection{Setting Up the IDT}

\begin{lstlisting}[style=console]
\end{lstlisting}

\begin{lstlisting}[style=console]
\end{lstlisting}




\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: env\_create()}]
\end{lstlisting}

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: env\_create()}]
\end{lstlisting}

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: env\_create()}]
\end{lstlisting}

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: env\_create()}]
\end{lstlisting}




\begin{lstlisting}[style=exercise]
\end{lstlisting}

\begin{lstlisting}[style=exercise]
\end{lstlisting}

\begin{lstlisting}[style=exercise]
\end{lstlisting}

\begin{lstlisting}[style=exercise]
\end{lstlisting}





\begin{lstlisting}[style=ccode, firstnumber=165, title={\scriptsize \ttfamily \bfseries inc/queue.h}]
\end{lstlisting}


\begin{lstlisting}[style=ccode, firstnumber=165, title={\scriptsize \ttfamily \bfseries inc/queue.h}]
\end{lstlisting}


\begin{lstlisting}[style=ccode, firstnumber=165, title={\scriptsize \ttfamily \bfseries inc/queue.h}]
\end{lstlisting}


\begin{lstlisting}[style=ccode, firstnumber=165, title={\scriptsize \ttfamily \bfseries inc/queue.h}]
\end{lstlisting}


\begin{lstlisting}[style=challenge]
\end{lstlisting}

\begin{lstlisting}[style=challenge]
\end{lstlisting}

\begin{lstlisting}[style=challenge]
\end{lstlisting}

\begin{lstlisting}[style=challenge]
\end{lstlisting}

\begin{lstlisting}[style=challenge]
\end{lstlisting}

\begin{lstlisting}[style=console]
\end{lstlisting}

\begin{lstlisting}[style=console]
\end{lstlisting}

\begin{lstlisting}[style=console]
\end{lstlisting}

\begin{lstlisting}[style=console]
\end{lstlisting}

\begin{lstlisting}[style=console]
\end{lstlisting}


\section{Page Faults, Breakpoints Exceptions, and System Calls}

\subsection{Handling Page Faults}

\subsection{The Breakpoint Exception}

\subsection{System calls}

\subsection{User-mode startup}

\subsection{Page faults and memory protection}


\clearpage

\end{CJK*}
\end{document}
	

e