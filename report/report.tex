\documentclass{article}

\usepackage{csquotes}
% 使用中文CJK包
\usepackage{CJK}
% 图像插入宏包
\usepackage{graphicx}
% 自定义颜色支持
\usepackage[usenames,dvipsnames]{color}
% 长表格跨页支持
\usepackage{longtable}
% 代码高亮支持
\usepackage{listings}
% 算法伪代码包
\usepackage[ruled,vlined]{algorithm2e}
% 自定义标题格式
\usepackage{titlesec}
% 扩展tabular样式
\usepackage{array}
% 添加页眉页脚
\usepackage{fancyhdr}
% 虚拟正文测试
\usepackage{lipsum}
% 数学环境包
\usepackage{amsmath}
% 首行缩进
\usepackage{indentfirst}
% 树状结构图
\usepackage{tree-dvips}
% 脚注环境
\usepackage{footnote}
% 定制表格线
\usepackage{makecell}
% tikz绘图包
\usepackage{tikz}
% URL超链接
\usepackage[dvips, colorlinks, linkcolor=black]{hyperref}
% 断行URL超链接
\usepackage{breakurl}


% hyperref中文兼容
\pdfstringdefDisableCommands{
\let\CJK@XX\relax
\let\CJK@XXX\relax
\let\CJK@XXXp\relax
\let\CJK@XXXX\relax
\let\CJK@XXXXp\relax
}

\usetikzlibrary{positioning,shapes,shadows,arrows}


% 设置脚注在table中可用
\makesavenoteenv{table}

% 设置标题格式
%\titleformat{\chapter}{\raggedright\Huge\bfseries}{Chapter \thechapter}{1em}{}

% 设置默认字体族, 具体字体请查看texdoc psnfss2e

% 设置Roman字体为Palatino
\renewcommand{\rmdefault}{ppl} 
% 设置TypeWriter字体为Courier
\renewcommand{\ttdefault}{pcr} 

% 设置行距
\setlength{\parskip}{1ex}

% 定义需要的颜色

\definecolor{lightgray}{RGB}{230,230,230}
\definecolor{lightblue}{RGB}{224, 224, 255}
\definecolor{darkblue}{RGB}{192, 192, 255}
\definecolor{lightpink}{RGB}{255, 224, 224}
\definecolor{darkpink}{RGB}{255, 192, 192}
\definecolor{keywordyellow}{RGB}{255, 204, 0}
\definecolor{keywordred}{RGB}{194, 58, 0}
\definecolor{numbercolor}{RGB}{102, 51, 0}

% 设置代码风格

% 定义makefile代码风格
\lstdefinestyle{mcode}
{ 
    language=make, 
    numbers=left, 
    numberstyle=\color{numbercolor},
    basicstyle=\scriptsize\ttfamily\bfseries,
    keywordstyle=\color{blue}, 
    commentstyle=\color{PineGreen},
    stringstyle=\color{red}, 
    frame=shadowbox, 
    frameround=tttt,
    breaklines=true,
    backgroundcolor=\color{lightgray} }
    
% 定义C语言代码风格
\lstdefinestyle{ccode}
{ 
    language=C, 
    numbers=left, 
    numberstyle=\color{numbercolor},
    basicstyle=\scriptsize\ttfamily\bfseries,
    keywordstyle=\color{blue}, 
    commentstyle=\color{PineGreen},
    stringstyle=\color{red}, 
    frame=shadowbox, 
    frameround=tttt,
    breaklines=true,
    backgroundcolor=\color{lightgray} }

% 定义汇编语言代码风格
\lstdefinestyle{acode}
{ 
    language=,
    morekeywords=[1]{mov, movl, movb, movw, orl, xorw, cli, cld, inb, testb, test, jnz, push, pop, jmp, call, lea, add, sub, ret, jle, outb, ljmp, lgdt, cmp, jne, popal, int, jns, pushw, pushal, pushl, popfl, addl, subl},
    morekeywords=[2]{ax, bx, cx, dx, eax, ebx, ecx, edx, cr0, cr1, cr2, cr3, al, ds, es, ss, esp, ebp, esi, edi}, 
    morekeywords=[3]{data, text, bss},
    morekeywords=[4]{long, align, p2align, ascii, fill, globl, space, set, rept, byte, word},
    morecomment=[l]\#,
    numbers=left, 
    numberstyle=\color{numbercolor},
    basicstyle=\scriptsize\ttfamily\bfseries,
    keywordstyle=[1]\color{blue}, 
    keywordstyle=[2]\color{keywordyellow},
    keywordstyle=[3]\color{orange},
    keywordstyle=[4]\color{keywordred},
    commentstyle=\color{PineGreen},
    stringstyle=\color{red}, 
    frame=shadowbox, 
    frameround=tttt,
    breaklines=true,
    backgroundcolor=\color{lightgray} }

    
% 定义命令行输出风格
\lstdefinestyle{console}
{
    language=bash, 
    numbers=none, 
    frame=tRBl,
    basicstyle=\scriptsize\color{green}\ttfamily\bfseries,     
    backgroundcolor=\color{black}}


% 定义exercise输出风格
\lstdefinestyle{exercise}
{
    numbers=none, 
    frame=tRBl,
    breaklines=true,
    breakindent=0pt,
    framexleftmargin=1em,
    framexrightmargin=1em,
    framextopmargin=2ex,
    framexbottommargin=2ex,
    xleftmargin=0.05\linewidth,
    xrightmargin=0.05\linewidth,
    basicstyle=\scriptsize\ttfamily\mdseries,   
    moredelim=[is][\ttfamily\bfseries]{|}{|},
    framerule=0.8pt,
    rulecolor=\color{darkblue}, 
    backgroundcolor=\color{lightblue}}
    

% 定义challenge输出风格
\lstdefinestyle{challenge}
{
    numbers=none, 
    frame=tRBl,
    breaklines=true,
    breakindent=0pt,
    framexleftmargin=1em,
    framexrightmargin=1em,
    framextopmargin=2ex,
    framexbottommargin=2ex,
    xleftmargin=0.05\linewidth,
    xrightmargin=0.05\linewidth,
    basicstyle=\scriptsize\ttfamily\mdseries,   
    moredelim=[is][\ttfamily\bfseries]{|}{|},
    framerule=0.8pt,
    rulecolor=\color{darkpink}, 
    backgroundcolor=\color{lightpink}}
    


% 非常重要, listings关闭非ASCII字符兼容
\lstset{extendedchars=false}


% 定义问题的答案格式
\newcommand{\highlight}[1]{{\bfseries \color{red}  #1}}
% 定义函数名格式
\newcommand{\funcname}[1]{{\ttfamily \small #1}}




\pagestyle{fancy}
\begin{document}
\begin{CJK*}{UTF8}{gkai}

\lhead{操作系统实习报告}
\rhead{张弛, 00848231}
\title{操作系统JOS实习第五次报告}
\author{张弛 \hspace{1ex} 00848231, \\
        zhangchitc@gmail.com}

\maketitle
% 记得在文档末尾插入\clearpage
\tableofcontents
\newpage

\section{Introduction}

我在实验中主要参考了华中科技大学邵志远老师写的JOS实习指导，在邵老师的主页上\burl{http://grid.hust.edu.cn/zyshao/OSEngineering.htm} 可以找到。但是这次实验的指导远远不如lab1的指导详尽，所以我这里需要补充的内容会很多。

内联汇编请参考邵老师的第二章讲义，对于语法讲解的很详细。

\section{File system preliminaries}

\subsection{On-Disk File System Structure}

\subsubsection{Sectors and Blocks}

\subsubsection{Superblocks}

\subsubsection{The Block Bitmap: Managing Free Disk Blocks}

\label{bitmap}

\subsubsection{File Meta-data}

\subsubsection{Directories versus Regular Files}

\section{The File System}

\subsection{Disk Access}

\begin{lstlisting}[style=exercise]
|Exercise 1|. Modify your kernel's environment initialization function, env_alloc in env.c, so that it gives environment 1 I/O privilege, but never gives that privilege to any other environment.

Make sure you can start the file environment without causing a General Protection fault. You should pass the "fs i/o" test in make grade.
\end{lstlisting}

材料中已经说的很明确了，只要在envs[1]被创建时候将EFLAGS置位即可：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c: env\_alloc ()}]
	// If this is the file server (e == &envs[1]) give it I/O privileges.
	// LAB 5: Your code here.
	if (e == &envs[1])
		e->env_tf.tf_eflags |= FL_IOPL_3;
\end{lstlisting}


材料里后来提了一句：

\begin{lstlisting}[style=exercise]
Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Make sure you understand how this environment state is handled.
\end{lstlisting}

然后我特意去看了一下进程切换的代码，关键部分应该是kern/env.c中的 \funcname{ env\_run()}

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/env.c}]
void
env_pop_tf(struct Trapframe *tf)
{
	__asm __volatile("movl %0,%%esp\n"
		"\tpopal\n"
		"\tpopl %%es\n"
		"\tpopl %%ds\n"
		"\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */
		"\tiret"
		: : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
}

void
env_run(struct Env *e)
{
    if (curenv != e) {
        curenv = e;
        curenv->env_runs ++;
        lcr3 (curenv->env_cr3);
    }

    env_pop_tf (&curenv->env_tf);
}
\end{lstlisting}

寄存器的恢复是在\funcname{env\_pop\_tf ()}中完成的，里面好像没有恢复eflags，但是我在lab3的报告里将\funcname{env\_pop\_tf ()}的过程进行了详细的说明，其中popal指令从栈中恢复了所有的通用寄存器，然后是在iret指令中恢复了eip, cs以及eflags寄存器。

\vspace{2em}

\hrule

\vspace{2em}

在继续作下面的部分前，我们先好好看一下文件系统实现的一些细节，看到：fs/fs.h

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/fs.h}]
#include <inc/fs.h>
#include <inc/lib.h>

#define SECTSIZE	512			// bytes per disk sector
#define BLKSECTS	(BLKSIZE / SECTSIZE)	// sectors per block

/* Disk block n, when in memory, is mapped into the file system
 * server's address space at DISKMAP + (n*BLKSIZE). */
#define DISKMAP		0x10000000

/* Maximum disk size we can handle (3GB) */
#define DISKSIZE	0xC0000000

struct Super *super;		// superblock
uint32_t *bitmap;		// bitmap blocks mapped in memory

/* ide.c */
bool	ide_probe_disk1(void);
void	ide_set_disk(int diskno);
int	ide_read(uint32_t secno, void *dst, size_t nsecs);
int	ide_write(uint32_t secno, const void *src, size_t nsecs);

/* bc.c */
void*	diskaddr(uint32_t blockno);
bool	va_is_mapped(void *va);
bool	va_is_dirty(void *va);
void	flush_block(void *addr);
void	bc_init(void);

/* fs.c */
void	fs_init(void);
int	file_get_block(struct File *f, uint32_t file_blockno, char **pblk);
int	file_create(const char *path, struct File **f);
int	file_open(const char *path, struct File **f);
ssize_t	file_read(struct File *f, void *buf, size_t count, off_t offset);
int	file_write(struct File *f, const void *buf, size_t count, off_t offset);
int	file_set_size(struct File *f, off_t newsize);
void	file_flush(struct File *f);
int	file_remove(const char *path);
void	fs_sync(void);

/* int	map_block(uint32_t); */
bool	block_is_free(uint32_t blockno);
int	alloc_block(void);

/* test.c */
void	fs_test(void);
\end{lstlisting}

从这里可以看到文件系统实现细节被分成了三个大的模块：

\begin{itemize}
\item{ide.c: 提供IDE磁盘的驱动，比如对特定扇区(sector)的读写以及切换操作磁盘（master和slave）}
\item{bc.c: 提供磁盘的块缓存实现机制，这个后面会详细说明。大体意义是因为磁盘最大可以支持到3G，而这么大的磁盘空间不可能是被同时使用的，所以当用户请求读写一块磁盘区域时，将其加载到文件系统进程的虚拟地址里，这样就可以用比较小的内存操作很大一块磁盘。而bc（磁盘块缓存）就是专门为文件系统服务进程实现这部分功能的模块}
\item{fs.c: 文件系统的核心功能，比如文件的增删和读写}
\end{itemize}

倒是材料里提到的fs/serv.c（真正的文件系统服务器进程的实现）我们可以稍等一下再来关注。

\subsection{The Block Cache}

这里描述了磁盘块缓冲的具体机制：

因为JOS支持的磁盘大小最大在3GB左右，所以我们可以使用类似lab4中实现fork的COW页面机制，也就是

\begin{enumerate}
\item{用文件系统服务进程的虚拟地址空间（4GB）对应到磁盘的地址空间上（3GB）}
\item{初始文件系统服务进程里什么页面都没映射，如果要访问一个磁盘的地址空间，则发生页错误}
\item{在页错误处理程序中，在内存中申请一个块的空间映射到相应的文件系统虚拟地址上，然后去实际的物理磁盘上读取这个区域的东西到这个内存区域上，然后恢复文件系统服务进程}
\end{enumerate}

这样就使用用户进程的机制完成了对于物理磁盘的读写机制，并且尽量少节省了内存。当然这里也有一个取巧的地方就是用虚拟地址空间模拟磁盘地址空间，但是材料中也提到了：

\begin{lstlisting}[style=exercise]
It would be awkward for a real file system implementation on a 32-bit machine to do this since modern disks are larger than 3GB.
\end{lstlisting}

因为一般机器硬盘显然不止3GB，但是一个32位机器虚拟地址只有4GB的地址空间，所以这里JOS的做法是为了方便而取了巧。

\vspace{3em}

\begin{lstlisting}[style=exercise]
|Exercise 2|. Implement the bc_pgfault and flush_block functions in fs/bc.c. bc_pgfault is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, except that its job is to load pages in from the disk in response to a page fault. When writing this, keep in mind that (1) addr may not be aligned to a block boundary and (2) ide_read operates in sectors, not blocks.

The flush_block function should write a block out to disk if necessary. flush_block shouldn't do anything if the block isn't even in the block cache (that is, the page isn't mapped) or if it's not dirty. We will use the VM hardware to keep track of whether a disk block has been modified since it was last read from or written to disk. To see whether a block needs writing, we can just look to see if the PTE_D "dirty" bit is set in the vpt entry. (The PTE_D bit is set by the processor in response to a write to that page; see 5.2.4.3 in chapter 5 of the 386 reference manual.) After writing the block to disk, flush_block should clear the PTE_D bit using sys_page_map.

Use make grade to test your code. Your code should pass "check_bc", "check_super", and "check_bitmap" for a score of 20/100.
\end{lstlisting}

首先我们要实现的是磁盘块缓冲的页面处理部分和写回部分，根据前面的铺垫，这两个地方要作的具体工作应该都很清楚了，他们主要用到的函数是跟磁盘直接交互的ide驱动：

\begin{lstlisting}[style=ccode]
int ide_read(uint32_t secno, void *dst, size_t nsecs);
int ide_write(uint32_t secno, void *dst, size_t nsecs);
\end{lstlisting}

secno对应IDE磁盘上的扇区编号，dst为当前文件系统服务程序空间中的对应地址，nsecs为读写的扇区数。了解完以后相应的编码就很简单了：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fc/bc.c}]
static void
bc_pgfault(struct UTrapframe *utf)
{
	void *addr = (void *) utf->utf_fault_va;
	uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE;
	int r;

	// Check that the fault was within the block cache region
	if (addr < (void*)DISKMAP || addr >= (void*)(DISKMAP + DISKSIZE))
		panic("page fault in FS: eip %08x, va %08x, err %04x",
		      utf->utf_eip, addr, utf->utf_err);

    
        // PGSIZE = BLKSIZE
        addr = ROUNDDOWN (addr, PGSIZE);

        if ((r = sys_page_alloc (0, addr, PTE_U|PTE_P|PTE_W)) < 0)
            panic ("bc_pgfault: page allocation failed : %e", r);

        // read the whole block[blockno]
        ide_read (blockno * BLKSECTS, addr, BLKSECTS);



	// Sanity check the block number. (exercise for the reader:
	// why do we do this *after* reading the block in?)
	if (super && blockno >= super->s_nblocks)
		panic("reading non-existent block %08x\n", blockno);

	// Check that the block we read was allocated.
	if (bitmap && block_is_free(blockno))
		panic("reading free block %08x\n", blockno);
}

void
flush_block(void *addr)
{
	uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE;

	if (addr < (void*)DISKMAP || addr >= (void*)(DISKMAP + DISKSIZE))
		panic("flush_block of bad va %08x", addr);

	// LAB 5: Your code here.

        addr = ROUNDDOWN (addr, PGSIZE);

        int r;

        if (va_is_mapped (addr) && va_is_dirty (addr)) {
            ide_write (blockno * BLKSECTS, addr, BLKSECTS);
        
            if ((r = sys_page_map (0, addr, 0, addr, PTE_USER)) < 0)
                panic ("flush_block: page mapping failed : %e", r);
        }
}
\end{lstlisting}

\vspace{2em}

做完这部分以后进行make qemu可以通过check\_bc, check\_super 以及 check\_bitmap 三个测试。他们是在 fs/fs.c中的 \funcname {fs\_init()} 中完成的：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/fs.c: fs\_init()}]
void
fs_init(void)
{
	static_assert(sizeof(struct File) == 256);

	// Find a JOS disk.  Use the second IDE disk (number 1) if available.
	if (ide_probe_disk1())
		ide_set_disk(1);
	else
		ide_set_disk(0);
	
	bc_init();

	// Set "super" to point to the super block.
	super = diskaddr(1);
	// Set "bitmap" to the beginning of the first bitmap block.
	bitmap = diskaddr(2);

	check_super();
	check_bitmap();
}
\end{lstlisting}

其中 \funcname{bc\_init()} 就是简单的安装一下页错误处理程序。主要是这里设置起了文件系统的超级块Super，可以看到文件系统将第Super块指向了文件系统的Block 1，然后块位图指向了Block 2。这里对应了在\ref{bitmap}中呈现的那张磁盘规划图。

块位图是没有相关结构的（因为就是直接读取特定二进制位），关于Super结构的具体定义在 inc/fs.h中:


\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries inc/fs.h}]
// See COPYRIGHT for copyright information.

#ifndef JOS_INC_FS_H
#define JOS_INC_FS_H

#include <inc/types.h>
#include <inc/mmu.h>

// File nodes (both in-memory and on-disk)

// Bytes per file system block - same as page size
#define BLKSIZE		PGSIZE
#define BLKBITSIZE	(BLKSIZE * 8)

// Maximum size of a filename (a single path component), including null
// Must be a multiple of 4
#define MAXNAMELEN	128

// Maximum size of a complete pathname, including null
#define MAXPATHLEN	1024

// Number of block pointers in a File descriptor
#define NDIRECT		10
// Number of direct block pointers in an indirect block
#define NINDIRECT	(BLKSIZE / 4)

#define MAXFILESIZE	((NDIRECT + NINDIRECT) * BLKSIZE)

struct File {
	char f_name[MAXNAMELEN];	// filename
	off_t f_size;			// file size in bytes
	uint32_t f_type;		// file type

	// Block pointers.
	// A block is allocated iff its value is != 0.
	uint32_t f_direct[NDIRECT];	// direct blocks
	uint32_t f_indirect;		// indirect block

	// Pad out to 256 bytes; must do arithmetic in case we're compiling
	// fsformat on a 64-bit machine.
	uint8_t f_pad[256 - MAXNAMELEN - 8 - 4*NDIRECT - 4];
} __attribute__((packed));	// required only on some 64-bit machines

// An inode block contains exactly BLKFILES 'struct File's
#define BLKFILES	(BLKSIZE / sizeof(struct File))

// File types
#define FTYPE_REG	0	// Regular file
#define FTYPE_DIR	1	// Directory


// File system super-block (both in-memory and on-disk)

#define FS_MAGIC	0x4A0530AE	// related vaguely to 'J\0S!'

struct Super {
	uint32_t s_magic;		// Magic number: FS_MAGIC
	uint32_t s_nblocks;		// Total number of blocks on disk
	struct File s_root;		// Root directory node
};
\end{lstlisting}

\begin{itemize}
\item{首先几个常数要读清楚，可以熟悉JOS的一些细节规定}
\item{一个File的大小为256 bytes，所以一个块中可以放下4个File结构。其具体的域在MIT材料的第一段预备知识中已经有过详细叙述}
\end{itemize}

从这里可以看到一个Super其实没有占用一个块大小，大概就是一个File大小（256）加两个DWORDS，而块位图则占用了8个块大小（BLKBITSIZE）。后面马上我们就要对相关结构进行处理。

\vspace{2em}
\hrule
\vspace{2em}

但是这里还有一个问题存在我的脑子中，就是我们这里只对Super指针的地址进行了赋值，那实际内存区域里存的东西是什么时候被初始化的呢？我找了很久，终于在张顺廷湿胸的提醒下去看了看fs/fsformat.c，才恍然大悟：

\begin{enumerate}
\item{首先，Super的指针赋值为：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/fs.c: fs\_init()}]
	// Set "super" to point to the super block.
	super = diskaddr(1);
}
\end{lstlisting}

diskaddr定义在fs/bc.c中：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/bc.c: diskaddr()}]
void*
diskaddr(uint32_t blockno)
{
	if (blockno == 0 || (super && blockno >= super->s_nblocks))
		panic("bad block number %08x in diskaddr", blockno);
	return (char*) (DISKMAP + blockno * BLKSIZE);
}
\end{lstlisting}

可见Super的位置是虚拟地址空间的第一块，当这个块被访问的时候，自然会使用磁盘块缓存机制读取到用户空间中，读取来源是IDE磁盘。
}

\item{这个IDE磁盘是哪里来的呢？在JOS里是以镜像文件由QEMU模拟成IDE磁盘的，产生方式在fs/Makefrag里有详细过程：

\begin{lstlisting}[style=mcode, title={\scriptsize \ttfamily \bfseries fs/Makefrag}]

OBJDIRS += fs

FSOFILES := 		$(OBJDIR)/fs/ide.o \
			$(OBJDIR)/fs/bc.o \
			$(OBJDIR)/fs/fs.o \
			$(OBJDIR)/fs/serv.o \
			$(OBJDIR)/fs/test.o \

USERAPPS := 		$(OBJDIR)/user/init

FSIMGTXTFILES :=	fs/newmotd \
			fs/motd



FSIMGFILES := $(FSIMGTXTFILES) $(USERAPPS)

$(OBJDIR)/fs/%.o: fs/%.c fs/fs.h inc/lib.h
	@echo + cc[USER] $<
	@mkdir -p $(@D)
	$(V)$(CC) -nostdinc $(USER_CFLAGS) -c -o $@ $<

$(OBJDIR)/fs/fs: $(FSOFILES) $(OBJDIR)/lib/entry.o $(OBJDIR)/lib/libjos.a user/user.ld
	@echo + ld $@
	$(V)mkdir -p $(@D)
	$(V)$(LD) -o $@ $(ULDFLAGS) $(LDFLAGS) -nostdlib \
		$(OBJDIR)/lib/entry.o $(FSOFILES) \
		-L$(OBJDIR)/lib -ljos $(GCC_LIB)
	$(V)$(OBJDUMP) -S $@ >$@.asm

# How to build the file system image
$(OBJDIR)/fs/fsformat: fs/fsformat.c
	@echo + mk $(OBJDIR)/fs/fsformat
	$(V)mkdir -p $(@D)
	$(V)gcc $(USER_CFLAGS) -o $(OBJDIR)/fs/fsformat fs/fsformat.c

$(OBJDIR)/fs/clean-fs.img: $(OBJDIR)/fs/fsformat $(FSIMGFILES)
	@echo + mk $(OBJDIR)/fs/clean-fs.img
	$(V)mkdir -p $(@D)
	$(V)$(OBJDIR)/fs/fsformat $(OBJDIR)/fs/clean-fs.img 1024 $(FSIMGFILES)

$(OBJDIR)/fs/fs.img: $(OBJDIR)/fs/clean-fs.img
	@echo + cp $(OBJDIR)/fs/clean-fs.img $@
	$(V)cp $(OBJDIR)/fs/clean-fs.img $@

all: $(OBJDIR)/fs/fs.img

#all: $(addsuffix .sym, $(USERAPPS))

#all: $(addsuffix .asm, $(USERAPPS))
\end{lstlisting}

注意从32行开始的编译：

\begin{enumerate}
\item{第32行：将fs/fsformat.c编译成可执行文件}
\item{第38行：使用fs/fsformat可执行文件产生镜像文件fs/clean-fs.img}
\item{第43行：将fs/clean-fs.img复制成真正的磁盘镜像文件fs/fs.img}
\end{enumerate}

我们主要关注第二步是如何产生fs/clean-fs.img的，可以看到它使用的命令为：

\begin{lstlisting}[style=mcode, firstnumber=41, title={\scriptsize \ttfamily \bfseries fs/Makefrag}]
$(V)$(OBJDIR)/fs/fsformat $(OBJDIR)/fs/clean-fs.img 1024 $(FSIMGFILES)
\end{lstlisting}

可以看到这个fs/fsformat接受了1024和一堆文件系统的目标文件生成了clean-fs.img，那么我们好奇这个fs/fsformat是干吗的呢？ 打开fs/fsformat.c来看看。
}

\item{fs/fsformat.c是一个创建磁盘的工具，我们就看看它的主函数:

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/fsformat.c: main()}]
int
main(int argc, char **argv)
{
	int i;
	char *s;
	struct Dir root;

	assert(BLKSIZE % sizeof(struct File) == 0);

	if (argc < 3)
		usage();

	nblocks = strtol(argv[2], &s, 0);
	if (*s || s == argv[2] || nblocks < 2 || nblocks > 1024)
		usage();

	opendisk(argv[1]);

	startdir(&super->s_root, &root);
	for (i = 3; i < argc; i++)
		writefile(&root, argv[i]);
	finishdir(&root);

	finishdisk();
	return 0;
}
\end{lstlisting}

可以从代码里看到它作了这么几件事：

\begin{enumerate}
\item{使用opendisk创建一个磁盘文件，超级块在这里被初始化}
\item{使用startdir创建根目录，并初始化超级块}
\item{使用writefile将目标文件写入磁盘映像}
\item{使用finishdir将根目录写入磁盘映像}
\item{使用finishdisk将块位图设置为正确的值，完成磁盘映像的创建}
\end{enumerate}

其中opendisk就是我们初始化Super超级块的地方。

}
\item{来看一下具体代码：
\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/fsformat.c: opendisk()}]
void
opendisk(const char *name)
{
	int r, diskfd, nbitblocks;

	if ((diskfd = open(name, O_RDWR | O_CREAT, 0666)) < 0)
		panic("open %s: %s", name, strerror(errno));

	if ((r = ftruncate(diskfd, 0)) < 0
	    || (r = ftruncate(diskfd, nblocks * BLKSIZE)) < 0)
		panic("truncate %s: %s", name, strerror(errno));

	if ((diskmap = mmap(NULL, nblocks * BLKSIZE, PROT_READ|PROT_WRITE,
			    MAP_SHARED, diskfd, 0)) == MAP_FAILED)
		panic("mmap %s: %s", name, strerror(errno));

	close(diskfd);

	diskpos = diskmap;
	alloc(BLKSIZE);
	super = alloc(BLKSIZE);
	super->s_magic = FS_MAGIC;
	super->s_nblocks = nblocks;
	super->s_root.f_type = FTYPE_DIR;
	strcpy(super->s_root.f_name, "/");

	nbitblocks = (nblocks + BLKBITSIZE - 1) / BLKBITSIZE;
	bitmap = alloc(nbitblocks);
	memset(bitmap, 0xFF, nbitblocks * BLKSIZE);
}
\end{lstlisting}

这里创建了映像文件，并为Super和bitmap分配好了空间（在文件中留出相应大小的空间）

}
\end{enumerate}

\vspace{2em}
\hrule
\vspace{2em}

其他的函数我们就不细看了，有兴趣的话可以自行研究。主要是通过Super的例子，我们看到了一个物理磁盘被创建以及其相应的所有细节被设置好的全过程。可以在后面的部分中弄清楚文件系统每个模块的来龙去脉。

\subsection{The Block Bitmap}

\begin{lstlisting}[style=exercise]
|Exercise 3|. Use free_block as a model to implement alloc_block, which should find a free disk block in the bitmap, mark it used, and return the number of that block. When you allocate a block, you should immediately flush the changed bitmap block to disk with flush_block, to help file system consistency.

Use make grade to test your code. Your code should now pass "alloc_block" for a score of 25/100.
\end{lstlisting}

这部分很简单，代码中告诉我们了在内存中直接查找bitmap的时间远远小于读取IDE磁盘的时间，可以不用在乎效率：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/fs.c: alloc\_block()}]
alloc_block(void)
{
    int blockno;
    for (blockno = 0; blockno < super->s_nblocks; blockno++)
        if (block_is_free (blockno)) {
            bitmap[blockno/32] ^= 1 << (blockno%32);
            flush_block (bitmap);
            return blockno;
        }
    
    return -E_NO_DISK;
}
\end{lstlisting}

\subsection{File Operations}


在进行下面的工作之前，先了解一下fs/fs.c中提供的各个函数的功能：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/fs.c}]
/* public */
void	fs_init(void);
int	file_get_block(struct File *f, uint32_t file_blockno, char **pblk);
int	file_create(const char *path, struct File **f);
int	file_open(const char *path, struct File **f);
ssize_t	file_read(struct File *f, void *buf, size_t count, off_t offset);
int	file_write(struct File *f, const void *buf, size_t count, off_t offset);
int	file_set_size(struct File *f, off_t newsize);
void	file_flush(struct File *f);
int	file_remove(const char *path);
void	fs_sync(void);
bool	block_is_free(uint32_t blockno);
int	alloc_block(void);


/* static */
static int file_block_walk(
        struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)

static int dir_lookup(
        struct File *dir, const char *name, struct File **file)

static int dir_alloc_file(
        struct File *dir, struct File **file)
        
static const char* skip_slash(const char *p)

static int walk_path(
        const char *path, struct File **pdir, struct File **pf, char *lastelem)
        
static int file_free_block(struct File *f, uint32_t filebno)

static void file_truncate_blocks(struct File *f, off_t newsize)

\end{lstlisting}

这里前面一部分public的函数应该无论是从函数名还是参数上都是比较明确的，就不再解释了，主要需要解释的是下面一部分静态函数：

\begin{description}
\item[file\_block\_walk(*f, filebno, ppdiskbno, alloc)]:\\
寻找一个文件结构f中的第filebno个块指向的硬盘块编号放入ppdiskbno，即如果filebno小于NDIRECT，则返回属于f\_direct[NDIRECT]中的相应链接，否则返回f\_indirect中查找的块。

如果alloc为真且相应硬盘块不存在，则分配一个。

当我们要将一个修改后的文件flush回硬盘，就需要使用这个函数找一个文件中链接的所有磁盘块，将他们都flush\_block
\item[dir\_lookup(*dir, *name, **file)]:\\
这个很明显了

\item[dir\_alloc\_file(*dir, **file)]:\\
在*dir对应的File结构中分配一个File的指针链接给*file，用于添加文件的操作。

\item[skip\_slash(*p)]:\\
用于路径中的字符串处理，调过斜杠。

\item[walk\_path(*path, **pdir, **pf, *lastlem)]:\\
*path为从根目录开始描述的文件名，如果成功找到了文件，则把相应的文件File结构赋值给*pf，其所在目录的File结构赋值给**pdir，lastlem为失败时最后剩下的文件名字。

\item[file\_free\_block(*f, filebno)]:\\
释放一个文件中的第filebno个磁盘块。此函数在file\_truncate\_blocks中被调用

\item[file\_truncate\_blocks(*f, newsize)]:\\
将文件设置为缩小后的新大小，清空那些被释放的物理块。

\end{description}

弄清楚函数功能以后就可以开始下面的工作了

\newpage

\begin{lstlisting}[style=exercise]
|Exercise 4|. Implement file_block_walk and file_get_block. file_block_walk maps from a block offset within a file to the pointer for that block in the struct File or the indirect block, very much like what pgdir_walk did for page tables. file_get_block goes one step further and maps to the actual disk block, allocating a new one if necessary.

Use make grade to test your code. Your code should pass "file_open", "file_get_block", and "file_flush/file_truncated/file rewrite" for a score of 40/100.
\end{lstlisting}


先来看 \funcname{file\_block\_walk()}：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/fs.c: file\_block\_walk()}]
static int
file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)
{
    int r;
    if (filebno >= NDIRECT + NINDIRECT)
        return -E_INVAL;

    if (filebno < NDIRECT) {
        if (ppdiskbno)
            *ppdiskbno = f->f_direct + filebno; 
        return 0;
    }

    if (!alloc && !f->f_indirect)
        return -E_NOT_FOUND;

    if (!f->f_indirect) {
        if ((r = alloc_block ()) < 0)
            return -E_NO_DISK;
        f->f_indirect = r;

        memset (diskaddr (r), 0, BLKSIZE);
        flush_block (diskaddr(r));
    }

    if (ppdiskbno)
        *ppdiskbno = (uint32_t *) diskaddr (f->f_indirect) + filebno - NDIRECT;

    return 0;
}
\end{lstlisting}

这里涉及到了对文件中对于磁盘块链接的操作，一定要明确一个概念：File结构中无论是f\_direct还是f\_indirect，\highlight{他们存储的都是指向的物理磁盘块的编号！如果要对指向的磁盘块进行读写，那么必须用diskaddr 转换成文件系统地址空间后才可以进行相应的操作}。

这里最需要注意的是如果申请了一个INDIRECT的链接块，一定要记得将其清空，并写回到磁盘中。

继续看\funcname{file\_get\_block()}:

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/fs.c: file\_get\_block()}]
int
file_get_block(struct File *f, uint32_t filebno, char **blk)
{
    int r;
    uint32_t *pdiskbno;

    if ((r = file_block_walk (f, filebno, &pdiskbno, 1)) < 0)
        return r;

    if (*pdiskbno == 0) {
        if ((r = alloc_block ()) < 0)
            return -E_NO_DISK;

        *pdiskbno = r;
        memset (diskaddr (r), 0, BLKSIZE);
        flush_block (diskaddr (r));
    }

    *blk = diskaddr (*pdiskbno);

    return 0;
}
\end{lstlisting}

这里有一个地方代码注释里没有说得太清楚，就是blk最后应该指向得到的blk对应在文件系统地址空间中的地址，所以最后需要用diskaddr转换。同样和上面的函数一样要记得写回新申请的物理块数据。


\subsection{Client/Server File System Access}

MIT的材料中在这部分开始实现文件系统的服务器端以及客户端的代码，两者通过RPC（Remote Process Call）实现通信。

\subsubsection{How RPC Works}

这部分内容在MIT材料上看到的时候就不是太理解，所以我专门去找了一下资料，下面的资料是在MSDN找到的，摘抄了一部分，详细的可以参考\burl{http://msdn.microsoft.com/en-us/library/aa374358(v=VS.85).aspx}

\vspace{2em}

{\sffamily \scriptsize \bfseries The RPC tools make it appear to users as though a client directly calls a procedure located in a remote server program. The client and server each have their own address spaces; that is, each has its own memory resource allocated to data used by the procedure. The following figure illustrates the RPC architecture.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.40]{/home/zhangchi/lab/report/rpc.png}
\end{figure}

As the illustration shows, the client application calls a local stub procedure instead of the actual code implementing the procedure. Stubs are compiled and linked with the client application. Instead of containing the actual code that implements the remote procedure, the client stub code:}

{\sffamily \scriptsize 
\begin{enumerate}
\item{Retrieves the required parameters from the client address space.}
\item{Translates the parameters as needed into a standard NDR format for transmission over the network.}
\item{Calls functions in the RPC client run-time library to send the request and its parameters to the server.}
\end{enumerate}
}


{\sffamily \scriptsize \bfseries 
The server performs the following steps to call the remote procedure.
}

{\sffamily \scriptsize
\begin{enumerate}
\item{The server RPC run-time library functions accept the request and call the server stub procedure.}
\item{The server stub retrieves the parameters from the network buffer and converts them from the network transmission format to the format the server needs.}
\item{The server stub calls the actual procedure on the server.}
\end{enumerate}
}

{\sffamily \scriptsize \bfseries 
The remote procedure then runs, possibly generating output parameters and a return value. When the remote procedure is complete, a similar sequence of steps returns the data to the client.
}

{\sffamily \scriptsize
\begin{enumerate}
\item{The remote procedure returns its data to the server stub.}
\item{The server stub converts output parameters to the format required for transmission over the network and returns them to the RPC run-time library functions.}
\item{The server RPC run-time library functions transmit the data on the network to the client computer.}
\end{enumerate}
}

{\sffamily \scriptsize \bfseries 
The client completes the process by accepting the data over the network and returning it to the calling function.
}

{\sffamily \scriptsize  
\begin{enumerate}
\item{The client RPC run-time library receives the remote-procedure return values and returns them to the client stub.}
\item{The client stub converts the data from its NDR to the format used by the client computer. The stub writes data into the client memory and returns the result to the calling program on the client.}
\item{The calling procedure continues as if the procedure had been called on the same computer.}
\end{enumerate}
}

{\sffamily \scriptsize \bfseries 
The run-time libraries are provided in two parts: an import library, which is linked with the application and the RPC run-time library, which is implemented as a dynamic-link library (DLL).

The server application contains calls to the server run-time library functions which register the server's interface and allow the server to accept remote procedure calls. The server application also contains the application-specific remote procedures that are called by the client applications.

}

\vspace{2em}
\hrule
\vspace{2em}

这个介绍大致能看清楚RPC的工作原理。对应到JOS，他们之间的联系是：

\begin{itemize}
\item{RPC的最底层传输层可以是network，这里我们JOS只是在IPC上实现的RPC}
\item{JOS中的Server Stub即fs/serv.c，Server Run-Time Library即fs/fs.c}
\item{JOS中的Client Stub即lib/fd.c，用于封装文件传输的细节，实际上一个文件可以对应一个实际文件，也可以是Socket，Pipe之类的}
\item{JOS中的Client Run-Time Library即lib/file.c，在这里对应真实文件系统的函数调用和数据传输}
\end{itemize}

\subsubsection{JOS C/S File System Access}

\begin{lstlisting}[style=exercise]
|Exercise 5|. Implement serve_read in fs/serv.c and devfile_read in lib/file.c.

serve_read's heavy lifting will be done by the already-implemented file_read in fs/fs.c (which, in turn, is just a bunch of calls to file_get_block). serve_read just has to provide the RPC interface for file reading. Look at the comments and code in serve_set_size to get a general idea of how the server functions should be structured.

Likewise, devfile_read should pack its arguments into fsipcbuf for serve_read, call fsipc, and handle the result.

Use make grade to test your code. Your code should pass "lib/file.c" and "file_read" for a score of 50/100.
\end{lstlisting}

这个Exercise里面我们主要来关注服务器端程序的架构，下个Exercise里会对客户端程序的结构进行说明。

首先有几个特别重要的结构需要了解，看到inc/fs.h

\begin{lstlisting}[style=ccode, firstnumber=76, title={\scriptsize \ttfamily \bfseries inc/fs.h}]
union Fsipc {
	struct Fsreq_open {
		char req_path[MAXPATHLEN];
		int req_omode;
	} open;
	struct Fsreq_set_size {
		int req_fileid;
		off_t req_size;
	} set_size;
	struct Fsreq_read {
		int req_fileid;
		size_t req_n;
	} read;
	struct Fsret_read {
		char ret_buf[PGSIZE];
	} readRet;
	struct Fsreq_write {
		int req_fileid;
		size_t req_n;
		char req_buf[PGSIZE - (sizeof(int) + sizeof(size_t))];
	} write;
	struct Fsreq_stat {
		int req_fileid;
	} stat;
	struct Fsret_stat {
		char ret_name[MAXNAMELEN];
		off_t ret_size;
		int ret_isdir;
	} statRet;
	struct Fsreq_flush {
		int req_fileid;
	} flush;
	struct Fsreq_remove {
		char req_path[MAXPATHLEN];
	} remove;
};
\end{lstlisting}

这里需要了解union Fsipc，文件系统中客户端和服务器端通过IPC进行通信，那么通信的数据格式就是union Fsipc（union用法请参考任何一本C语言手册），它里面的每一个成员对应一种文件系统的操作请求。每次客户端发来请求，都会将参数放入一个union Fsipc映射到一个物理页传递给服务器端，同时有时候服务器还会将处理以后的结果放入Fsipc内，传递给用户程序。这里就涉及到文件服务器程序的地址空间的布局：

\begin{lstlisting}[style=ccode]
/*
 *    4 Gig -------->  +------------------------------+
 *                     :              .               :
 *                     :              .               :
 *                     :              .               :
 *    USTACKTOP  --->  +------------------------------+ 0xeebfe000
 *                     |      Normal User Stack       | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebfd000
 *                     :              .               :
 *                     :              .               :
 *                     +------------------------------+ 
 *                     |            1024              | 1024 x PGSIZE
 *                     |         struct Fd *          | 
 * DISKMAP + DISKSIZE  +------------------------------+ 0xd0000000
 *                     |                              | 
 *                     |                              | 
 *                     |      3GB IDE Disk Space      |
 *                     |                              | 
 *                     |                              | 
 *    DISKMAP   --->   +------------------------------+ 0x10000000
 *                     |      union Fsipc *fsreq      | RW/RW  PGSIZE
 *    fsreq     --->   +------------------------------+ 0x0ffff000
 *                     :              .               :
 *                     :              .               :
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
 *                     |     Program Data & Heap      |
 *    UTEXT -------->  +------------------------------+ 0x00800000
 *    PFTEMP ------->  |       Empty Memory (*)       |        PTSIZE
 *                     |                              |
 *    UTEMP -------->  +------------------------------+ 0x00400000      --+
 *                     |       Empty Memory (*)       |                   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |  User STAB Data (optional)   |                 PTSIZE
 *    USTABDATA ---->  +------------------------------+ 0x00200000        |
 *                     |       Empty Memory (*)       |                   |
 *    0 ------------>  +------------------------------+                 --+
 *
 */
\end{lstlisting}

上图我们已经明确的画出了服务器端程序的虚拟空间示意图，需要注意的仅仅是它和普通用户程序不同的地方：

\begin{description}
\item[$[\mathrm{DISKMAP}, \mathrm{DISKMAP} + \mathrm{DISKSIZE})$]: \\
前面提到过很多次了，这部分空间映射了3GB的对应IDE磁盘空间。
\item[$[\mathrm{0x0ffff000}, \mathrm{DISKMAP})$]: \\
一次IPC请求的union Fsipc放置的地址空间。
\item[$[\mathrm{0xd0000000}, \mathrm{0xd0000000} + 1024 \times \mathrm{PGSIZE})$]: \\
这片空间有1024个物理页，每个物理页对应一个struct Fd，这个我们留在后面讲。
\item[其他区域]:\\
和普通用户程序一样，UTEXT往上是代码段和部分数据，USTACKTOP下面是用户栈，往上是操作系统预留的系统栈和环境等等。
\end{description}

打开fs/serv.c，可以看到它定义的唯一一个全局变量opentab：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/serv.c}]
#include <inc/x86.h>
#include <inc/string.h>

#include "fs.h"

#define debug 0

struct OpenFile {
	uint32_t o_fileid;	// file id
	struct File *o_file;	// mapped descriptor for open file
	int o_mode;		// open mode
	struct Fd *o_fd;	// Fd page
};

// Max number of open files in the file system at once
#define MAXOPEN		1024
#define FILEVA		0xD0000000

// initialize to force into data section
struct OpenFile opentab[MAXOPEN] = {
	{ 0, 0, 1, 0 }
};

// Virtual address at which to receive page mappings containing client requests.
union Fsipc *fsreq = (union Fsipc *)0x0ffff000;
\end{lstlisting}


OpenFile结构是服务器程序维护的一个映射，它将一个真实文件struct File和用户客户端打开的文件描述符struct Fd对应到一起（具体struct Fd代表的意义见下段）。每个被打开的文件对应的struct Fd都被映射到FILEVA上往上的一个物理页，服务器程序和打开这个文件的客户程序共享这个物理页。客户端程序和文件系统服务器通信时使用o\_fileid来指定要操作的文件。

文件系统默认最大同时可以打开的文件个数为1024，所以有1024个struct Openfile。所以对应着在服务器地址空间0xd0000000往上留出了1024个物理页用于映射这些对应的struct Fd。


具体的struct Fd被定义在inc/fd.h中：


\begin{lstlisting}[style=ccode, firstnumber=26, title={\scriptsize \ttfamily \bfseries inc/fd.h}]
struct FdFile {
	int id;
};
 
struct Fd {
	int fd_dev_id;
	off_t fd_offset;
	int fd_omode;
	union {
		// File server files
		struct FdFile fd_file;
	};
};
\end{lstlisting}

它是一个抽象层，因为JOS和Linux一样，所有的IO都是文件，所以用户看到的都是Fd代表的文件，但是Fd会记录其对应的具体对象，比如真实文件、Socket和管道等等，因为我们现在只有文件，所以看到union里只有一个FdFile，后面如果有其他类型的对象加入，那么union里会有其他的内容。

\vspace{2em}
\hrule
\vspace{2em}

至此我们已经搞明白了服务器段程序的内存结构，然后我们来看看它会作一些什么工作：


\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/serv.c: serve()}]
void
serve(void)
{
    uint32_t req, whom;
    int perm, r;
    void *pg;

    while (1) {
        perm = 0;
        req = ipc_recv((int32_t *) &whom, fsreq, &perm);
        if (debug)
            cprintf("fs req %d from %08x [page %08x: %s]\n",
                req, whom, vpt[VPN(fsreq)], fsreq);

        // All requests must contain an argument page
        if (!(perm & PTE_P)) {
            cprintf("Invalid request from %08x: no argument page\n", whom);
            continue; // just leave it hanging...
        }

        pg = NULL;
        if (req == FSREQ_OPEN) {
            r = serve_open(whom, (struct Fsreq_open*)fsreq, &pg, &perm);
        } else if (req < NHANDLERS && handlers[req]) {
            r = handlers[req](whom, fsreq);
        } else {
            cprintf("Invalid request code %d from %08x\n", whom, req);
            r = -E_INVAL;
        }
        ipc_send(whom, r, pg, perm);
        sys_page_unmap(0, fsreq);
    }
}
\end{lstlisting}

服务器主循环会使用轮询的方式接受客户端程序的文件请求，每次

\begin{enumerate}
\item{从IPC接受一个请求类型req以及数据页fsreq}
\item{然后根据req来执行相应的服务程序}
\item{将相应服务程序的执行结果（如果产生了数据页则有pg）通过IPC发送回调用进程}
\item{将映射好的物理页fsreq取消映射}
\end{enumerate}

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/serv.c}]
typedef int (*fshandler)(envid_t envid, union Fsipc *req);

fshandler handlers[] = {
	// Open is handled specially because it passes pages
	/* [FSREQ_OPEN] =	(fshandler)serve_open, */
	[FSREQ_SET_SIZE] =	(fshandler)serve_set_size,
	[FSREQ_READ] =		serve_read,
	[FSREQ_WRITE] =		(fshandler)serve_write,
	[FSREQ_STAT] =		serve_stat,
	[FSREQ_FLUSH] =		(fshandler)serve_flush,
	[FSREQ_REMOVE] =	(fshandler)serve_remove,
	[FSREQ_SYNC] =		serve_sync
};
#define NHANDLERS (sizeof(handlers)/sizeof(handlers[0]))
\end{lstlisting}

服务程序被定义在了handler数组里，通过请求号进行调用，具体定义在

\begin{lstlisting}[style=ccode, firstnumber=74, title={\scriptsize \ttfamily \bfseries inc/lib.h}]
// Definitions for requests from clients to file system
enum {
	FSREQ_OPEN = 1,
	FSREQ_SET_SIZE,
	// Read returns a Fsret_read on the request page
	FSREQ_READ,
	FSREQ_WRITE,
	// Stat returns a Fsret_stat on the request page
	FSREQ_STAT,
	FSREQ_FLUSH,
	FSREQ_REMOVE,
	FSREQ_SYNC
};
\end{lstlisting}

\vspace{2em}
\hrule
\vspace{2em}

以上就是我们需要了解的结构部分，现在开始我们可以进行下面的编码了，先看fs/serv.c的 \funcname{serve\_read ()} :


\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/serv.c: serve\_read()}]
int
serve_read(envid_t envid, union Fsipc *ipc)
{
    struct Fsreq_read *req = &ipc->read;
    struct Fsret_read *ret = &ipc->readRet;

    if (debug)
        cprintf("serve_read %08x %08x %08x\n", envid, req->req_fileid, req->req_n);

    struct OpenFile *o;
    int r;

    // openfile_lookup returns the struct OpenFile *o 
    if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)
		return r;

    int req_n = req->req_n > PGSIZE ? PGSIZE : req->req_n;
    if ((r = file_read (o->o_file, ret->ret_buf, req_n, o->o_fd->fd_offset)) < 0)
        return r;

    o->o_fd->fd_offset += r;

    return r;
}
\end{lstlisting}

注意前面我们提到了Fsipc地址为请求参数的位置，同时文件系统还有可能将其用作结果返回，这里的读取过程就用到了。

然后是lib/file.c中用户发出读取请求的函数\funcname{devfile\_read ()}:

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries lib/file.c: devfile\_read()}]
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
    fsipcbuf.read.req_fileid = fd->fd_file.id;
    fsipcbuf.read.req_n = n;

    int r;
    if ((r = fsipc (FSREQ_READ, NULL)) < 0)
        return r;

    memmove (buf, fsipcbuf.readRet.ret_buf, r);

    return r;
}
\end{lstlisting}

这里编码很简单，就是对于客户端程序的结构还没有熟悉，所以这里的 \funcname{fsipc()} 对我们还很陌生，我们下节马上会进行详细的介绍。

\vspace{2em}

\begin{lstlisting}[style=exercise]
|Exercise 6|. Implement serve_write in fs/serv.c and devfile_write in lib/file.c.

Use make grade to test your code. Your code should pass "file_write" and "file_read after file_write" for a score of 60/100.
\end{lstlisting}

这里的编码跟上边如出一辙，就不再赘述了：
\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries fs/serv.c: serve\_write()}]
int
serve_write(envid_t envid, struct Fsreq_write *req)
{
    if (debug)
        cprintf("serve_write %08x %08x %08x\n", envid, req->req_fileid, req->req_n);

    struct OpenFile *o;
    int r;

    // openfile_lookup returns the struct OpenFile *o 
    if ((r = openfile_lookup(envid, req->req_fileid, &o)) < 0)
		return r;

    int req_n = req->req_n > PGSIZE ? PGSIZE : req->req_n;
    if ((r = file_write (o->o_file, req->req_buf, req_n, o->o_fd->fd_offset)) < 0)
        return r;

    o->o_fd->fd_offset += r;

    return r;
}
\end{lstlisting}

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries lib/file.c: devfile\_write()}]
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
    if (n > sizeof (fsipcbuf.write.req_buf))
        n = sizeof (fsipcbuf.write.req_buf);

    fsipcbuf.write.req_fileid = fd->fd_file.id;
    fsipcbuf.write.req_n = n;

    memmove (fsipcbuf.write.req_buf, buf, n);

    int r;
    if ((r = fsipc (FSREQ_WRITE, NULL)) < 0)
        return r;

    return r;
}
\end{lstlisting}


\subsection{Client-Side File Operations}

因为引进了文件系统，为了使得用户程序能够使用文件，JOS的库文件和相应程序头也作了少许的改动，看到用户程序入口lib/entry.S:

\begin{lstlisting}[style=acode, title={\scriptsize \ttfamily \bfseries lib/entry.S}]
#include <inc/mmu.h>
#include <inc/memlayout.h>

.data
	// define page-aligned fsipcbuf for fsipc.c
	// ... and fdtab for file.c
	.p2align PGSHIFT
	.globl fsipcbuf
fsipcbuf:
	.space PGSIZE
	.globl fdtab
fdtab:
	.space PGSIZE


// Define the global symbols 'envs', 'pages', 'vpt', and 'vpd'
// so that they can be used in C as if they were ordinary global arrays.
	.globl envs
	.set envs, UENVS
	.globl pages
	.set pages, UPAGES
	.globl vpt
	.set vpt, UVPT
	.globl vpd
	.set vpd, (UVPT+(UVPT>>12)*4)
\end{lstlisting}

这里多定义了两个位置：

\begin{itemize}
\item{fsipcbuf: 和文件系统共享的物理页用于交换数据}
\item{fdtab：这个在整个JOS我都没找到使用它的地方，暂时可以忽略它}
\end{itemize}

然后看到系统库文件lib/fd.c，这个库是帮用户维护所有文件描述符(File Descriptor)的模块：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries lib/fd.c}]
#include <inc/lib.h>

#define debug		0

// Maximum number of file descriptors a program may hold open concurrently
#define MAXFD		32
// Bottom of file descriptor area
#define FDTABLE		0xD0000000
// Bottom of file data area.  We reserve one data page for each FD,
// which devices can use if they choose.
#define FILEDATA	(FDTABLE + MAXFD*PGSIZE)

// Return the 'struct Fd*' for file descriptor index i
#define INDEX2FD(i)	((struct Fd*) (FDTABLE + (i)*PGSIZE))
// Return the file data page for file descriptor index i
#define INDEX2DATA(i)	((char*) (FILEDATA + (i)*PGSIZE))
\end{lstlisting}

看到这段声明可以知道，在用户程序编译之后，fd.c为其在FDTABLE（0xD0000000）开始的地址留出了MAXFD（32）个物理页的位置，每一页对应存放一个struct Fd，保存当前用户程序打开的文件，系统默认一个程序同时最多能打开32个。

fd.c提供上层抽象到具体IO操作对象的对应，使用struct Dev来作为中间的过渡，在inc/fd.h中提供如下接口：

\begin{lstlisting}[style=ccode, firstnumber=47, title={\scriptsize \ttfamily \bfseries inc/fd.h}]
char*	fd2data(struct Fd *fd);
int	fd2num(struct Fd *fd);
int	fd_alloc(struct Fd **fd_store);
int	fd_close(struct Fd *fd, bool must_exist);
int	fd_lookup(int fdnum, struct Fd **fd_store);
int	dev_lookup(int devid, struct Dev **dev_store);

extern struct Dev devfile;
\end{lstlisting}

我们看看struct Dev的具体定义：

\begin{lstlisting}[style=ccode, firstnumber=16, title={\scriptsize \ttfamily \bfseries inc/fd.h}]
struct Dev {
	int dev_id;
	char *dev_name;
	ssize_t (*dev_read)(struct Fd *fd, void *buf, size_t len);
	ssize_t (*dev_write)(struct Fd *fd, const void *buf, size_t len);
	int (*dev_close)(struct Fd *fd);
	int (*dev_stat)(struct Fd *fd, struct Stat *stat);
	int (*dev_trunc)(struct Fd *fd, off_t length);
};
\end{lstlisting}

这个结构的成员为一系列的函数指针，对应不同设备的各自操作函数。

看到Dev的结构定义之后，我们注意到前面在inc/fd.h中链接了struct Dev devfile，我们看一下devfile的具体声明位置lib/file.c：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries lib/file.c}]

static int devfile_flush(struct Fd *fd);
static ssize_t devfile_read(struct Fd *fd, void *buf, size_t n);
static ssize_t devfile_write(struct Fd *fd, const void *buf, size_t n);
static int devfile_stat(struct Fd *fd, struct Stat *stat);
static int devfile_trunc(struct Fd *fd, off_t newsize);

struct Dev devfile =
{
	.dev_id =	'f',
	.dev_name =	"file",
	.dev_read =	devfile_read,
	.dev_write =	devfile_write,
	.dev_close =	devfile_flush,
	.dev_stat =	devfile_stat,
	.dev_trunc =	devfile_trunc
};
\end{lstlisting}


再看看lib/fd.c中的各函数代码即可知道，用户通过调用lib/fd.c中的fd\_*等一系列函数，他们的具体实现在lib/fd.c中，这些函数只是简单的对参数进行检查以后，就直接调用devfile中对应的函数指针。因为devfile对应的IO设备为文件系统，所以这些函数指向的是lib/file.c中的和文件系统服务器的RPC通信函数。


这时我们终于完整的搞清楚了整个C/S架构的文件系统调用机制：

{ \footnotesize
\begin{verbatim}

                 Regular env           FS env
              +---------------+   +---------------+
              |      read     |   |   file_read   |
              |   (lib/fd.c)  |   |   (fs/fs.c)   |
     .........|.......|.......|...|.......^.......|...............
              |       v       |   |       |       | RPC mechanism
              |  devfile_read |   |  serve_read   |
              |  (lib/file.c) |   |  (fs/serv.c)  |
              |       |       |   |       ^       |
              |       v       |   |       |       |
              |     fsipc     |   |     serve     |
              |  (lib/file.c) |   |  (fs/serv.c)  |
              |       |       |   |       ^       |
              |       v       |   |       |       |
              |   ipc_send    |   |   ipc_recv    |
              |       |       |   |       ^       |
              +-------|-------+   +-------|-------+
                      |                   |
                      +-------------------+
\end{verbatim}
}

\newpage

\begin{lstlisting}[style=exercise]
|Exercise 7|. Implement open. The open function must find an unused file descriptor using the fd_alloc() function we have provided, make an IPC request to the file system environment to open the file, and return the number of the allocated file descriptor. Be sure your code fails gracefully if the maximum number of files are already open, or if any of the IPC requests to the file system environment fail.

Use make grade to test your code. Your code should pass "open", "motd display", and "motd change" for a score of 85/100.
\end{lstlisting}

现在我们可以开始着手编写客户端的系统库了，稍微了解一下lib/file.c的代码以后需要明确一个函数：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries lib/file.c: fsipc()}]
static int
fsipc(unsigned type, void *dstva)
{
	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", env->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(envs[1].env_id, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
	return ipc_recv(NULL, dstva, NULL);
}
\end{lstlisting}

所有的文件操作都通过 \funcname{fsipc()} 向文件服务器发送ipc请求，type为请求类型，dstva为如果需要和文件服务器程序共享物理页（比如马上要写的open打开文件共享struct Fd），那么就需要将dstva设置为正确的物理页地址。

好了，我们可以开始编写 \funcname{open()} 了：


\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries lib/file.c: open()}]
int
open(const char *path, int mode)
{
    struct Fd *fd_store;
    int r;

    if (strlen (path) >= MAXPATHLEN)
        return -E_BAD_PATH;

    if ((r = fd_alloc (&fd_store)) < 0)
        return r;

    strcpy (fsipcbuf.open.req_path, path);
    fsipcbuf.open.req_omode = mode;

    if ((r = fsipc (FSREQ_OPEN, (void *) fd_store)) < 0) {
        fd_close (fd_store, 0);
        return r;
    }

    return fd2num (fd_store);
}
\end{lstlisting}

没什么好说的，记得最后返回的值应该用fd2num转化成index即可

\subsection{Spawning Processes}

\begin{lstlisting}[style=exercise]
|Exercise 8|. spawn relies on the new syscall sys_env_set_trapframe to initialize the state of the newly created environment. Implement sys_env_set_trapframe. Test your code by running the user/icode program from kern/init.c, which will attempt to spawn /init from the file system. (Hint: If this fails in diskaddr, something's probably wrong with your indirect block code, since this is the first time we've used files that large.)

Use make grade to test your code. Your code should score 100/100.
\end{lstlisting}

如果仅仅只是完成 \funcname{sys\_env\_set\_trapframe() }还是很简单的：

\begin{lstlisting}[style=ccode, title={\scriptsize \ttfamily \bfseries kern/: ()}]
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
    struct Env *e;
    if (envid2env (envid, &e, 1) < 0)
        return -E_BAD_ENV;

    user_mem_assert (e, tf, sizeof (struct Trapframe), PTE_U);

    e->env_tf = *tf;
    e->env_tf.tf_cs = GD_UT | 3;
    e->env_tf.tf_eflags |= FL_IF;
    
    return 0;
}
\end{lstlisting}

完成系统调用后记得在 \funcname{syscall()} 里添加上分发逻辑。

至此lab5就全部完成了，但是我们实际上并没有完全知道spawn函数的具体流程，实际上很复杂:

\begin{enumerate}
\item{从文件系统打开对应的文件，准备从文件中读取ELF内容信息；}
\item{使用exofork创建子进程；}
\item{为子进程初始化堆栈空间；
\begin{enumerate}
    \item{因为对于该进程还有相应要传入的参数，所以要将这些参数合理的安排进用户栈中}
    \item{将子进程的esp栈顶指针设置为合适的位置}
\end{enumerate}
}
\item{将文件对应的ELF文件载入到子进程的地址空间中，记住在这里要为他们分配物理页面；}
\item{设置子进程的各个寄存器，eip等于ELF文件的入口地址；}
\item{设置子进程为可运行；}
\end{enumerate}

过程很繁琐，具体可以参考lib/spawn.c，这里不再深究。


\clearpage

\end{CJK*}
\end{document}
	

e